**双指针**   
1.344. 反转字符串     
思路: 
```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left=0, right=s.size()-1;
        while(left<right){
            swap(s[left], s[right]);
            ++left;
            --right;
        }
    }
};
执行耗时:28 ms,击败了7.81% 的C++用户     
内存消耗:22.5 MB,击败了86.15% 的C++用户         
```

2.面试题 16.24. 数对和  
思路:
```c++
class Solution {
public:
    vector<vector<int>> pairSums(vector<int>& nums, int target) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        int left=0, right=nums.size()-1;
        while(left < right){
            if(nums[left]+nums[right] == target){
                res.push_back({nums[left], nums[right]});
                ++left;
                --right;
            }
            else if(nums[left]+nums[right] > target){
                --right;
            }
            else{
                ++left;
            }
        }
        return res;
    }
};
执行耗时:96 ms,击败了53.47% 的C++用户      
内存消耗:44.8 MB,击败了46.95% 的C++用户
```

3.1. 两数之和          
思路: 暴力
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        for(int i=0; i<n; i++){
            for(int j=i+1; j<n; j++){
                if(nums[i]+nums[j] == target)
                    return {i, j};
            }
        }
        return {};
    }
};
执行耗时:284 ms,击败了29.11% 的C++用户       
内存消耗:9.9 MB,击败了70.62% 的C++用户       
```

思路: 哈希
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> umap;
        umap.clear();
        for(int i=0; i<nums.size(); i++){
            auto iter = umap.find(target-nums[i]);
            if(iter != umap.end())
                return {iter->second, i};
            umap[nums[i]] = i;
        }
        return {};
    }
};
执行耗时:12 ms,击败了61.81% 的C++用户      
内存消耗:10.4 MB,击败了56.14% 的C++用户       
```

思路: 双指针   
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> numsCopy= nums;
        sort(numsCopy.begin(), numsCopy.end());
        int left=0, right=numsCopy.size()-1;
        while(left < right){
            if(numsCopy[left]+numsCopy[right] == target){
                break;
            }
            else if(numsCopy[left]+numsCopy[right] < target){
                ++left;
            }
            else{
                --right;
            }
        }
        int val1 = numsCopy[left], val2 = numsCopy[right];
        int k=0, l=0, count=0;
        for(int i=0; i<nums.size(); i++){
            if(val1 == nums[i]){
                if(count == 0){
                    k = i;
                }
                ++count;
            }
            if(val2 == nums[i]){
                l = i;
            }
        }
        if(k == l)
            return {};
        return {k, l};
    }
};
执行耗时:8 ms,击败了91.83% 的C++用户       
内存消耗:10.1 MB,击败了59.64% 的C++用户      
```

4.15. 三数之和     
思路:
```c++


```

5.剑指 Offer 21. 调整数组顺序使奇数位于偶数前面     
思路:
```c++
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        int left=0, right=nums.size()-1;
        while(left<right){
            if(nums[left]%2 == 1){
                ++left;
            }
            else if(nums[right]%2 == 0){
                --right;
            }else{
                swap(nums[left], nums[right]);
                ++left;
                --right;
            }
        }
        return nums;
    }
};
执行耗时:20 ms,击败了34.36% 的C++用户    
内存消耗:17.8 MB,击败了11.33% 的C++用户
```

6.75. 颜色分类     
思路: 冒泡算法
```c++
class Solution {
public:
//输入：nums = [2,0,2,1,1,0]
//输出：[0,0,1,1,2,2]
    void sortColors(vector<int>& nums) {
        for(int i=0; i<nums.size(); i++){
            for(int j=i+1; j<nums.size(); j++){
                if(nums[i] > nums[j])
                    swap(nums[i], nums[j]);
            }
        }
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户  
内存消耗:8 MB,击败了54.59% 的C++用户
```

7.283. 移动零已排序未排序指针     
思路: 双指针       
```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int j=0;
        for(int i=0; i<nums.size(); i++){
            if(nums[i] != 0){
                swap(nums[i], nums[j++]);
            }
        }
    }
};
执行耗时:20 ms,击败了62.59% 的C++用户   
内存消耗:18.7 MB,击败了65.35% 的C++用户
```

8.面试题 16.06. 最小差类似合并两个有序数组     
思路: 双指针解法
```c++
class Solution {
public:
    int smallestDifference(vector<int>& a, vector<int>& b) {
        sort(a.begin(), a.end());
        sort(b.begin(), b.end());
        long res = INT_MAX;
        int len1 = a.size();
        int len2 = b.size();
        int i=0, j=0;
        while(i<len1 && j<len2){
            res = min(res, abs(long(a[i])-long(b[j])));
            if(a[i]-b[j] < 0){
                ++i;
            }else{
                ++j;
            }
        }
        return res;
    }
};
执行耗时:92 ms,击败了32.74% 的C++用户       
内存消耗:34.6 MB,击败了24.15% 的C++用户     
```

9.面试题 17.11. 单词距离类似合并两个有序数组  
思路: 暴力解法     
```c++
class Solution {
public:
    int findClosest(vector<string>& words, string word1, string word2) {
        vector<int> index1, index2;
        int res = INT_MAX;
        for(int i=0; i<words.size(); i++){
            if(words[i] == word1)
                index1.push_back(i);
            if(words[i] == word2)
                index2.push_back(i);
        }
        for(auto it1 : index1){
            for(auto it2 : index2){
                res = min(res, abs(it1-it2));
            }
        }
        return res;
    }
};
执行耗时:100 ms,击败了54.86% 的C++用户       
内存消耗:58 MB,击败了55.62% 的C++用户      
```
思路: 双指针解法
```c++
class Solution {
public:
    int findClosest(vector<string>& words, string word1, string word2) {
        vector<int> index1, index2;
        int res = INT_MAX;
        for(int i=0; i<words.size(); i++){
            if(words[i] == word1)
                index1.push_back(i);
            if(words[i] == word2)
                index2.push_back(i);
        }
        int len1 = index1.size();
        int len2 = index2.size();
        int i=0, j=0;
        while(i<len1 && j<len2){
            res = min(res, abs(index1[i]-index2[j]));
            if(index1[i] < index2[j]){
                ++i;
            }else{
                ++j;
            }
        }
        return res;
    }
};
执行耗时:120 ms,击败了23.58% 的C++用户        
内存消耗:58.1 MB,击败了21.51% 的C++用户         
```

___

**滑动窗口**  
1.剑指 Offer 57 - II. 和为s的连续正数序列     
思路:
```c++


```

2.剑指 Offer 48. 最长不含重复字符的子字符串   
思路:
```c++


```

3.438. 找到字符串中所有字母异位词          
思路:
```c++


```

4.76. 最小覆盖子串        
思路:
```c++


```
___

**前缀后缀统计**      
1.53. 最大子序和（例题1）    
思路:
```c++


```
2.121. 买卖股票的最佳时机（例题2）    
思路:
```c++


```
3.238. 除自身以外数组的乘积（例题3）    
思路:
```c++


```
4.面试题 05.03. 翻转数位   
思路:
```c++


```
5.42. 接雨水    
思路:
```c++


```
___


**位运算**    
1.191. 位1的个数（例题1）  
思路:
```c++


```
2.461. 汉明距离（例题2）    
思路:
```c++


```
3.面试题 05.06. 整数转换  
思路:
```c++


```
4.面试题 05.07. 配对交换  
思路:
```c++


```
5.面试题 05.01. 插入  
思路:
```c++


```
6.面试题 17.04. 消失的数字   
思路:
```c++


```
7.剑指 Offer 56 - I. 数组中数字出现的次数  
思路:
```c++


```
8.剑指 Offer 56 - II. 数组中数字出现的次数 II  
思路:
```c++


```
9.面试题 16.01. 交换数字  
思路:
```c++


```
10.231. 2 的幂   
思路:
```c++


```

___


