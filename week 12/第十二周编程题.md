**双指针**   
1.344. 反转字符串     
思路: 
```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left=0, right=s.size()-1;
        while(left<right){
            swap(s[left], s[right]);
            ++left;
            --right;
        }
    }
};
执行耗时:28 ms,击败了7.81% 的C++用户     
内存消耗:22.5 MB,击败了86.15% 的C++用户         
```

2.面试题 16.24. 数对和  
思路:
```c++
class Solution {
public:
    vector<vector<int>> pairSums(vector<int>& nums, int target) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        int left=0, right=nums.size()-1;
        while(left < right){
            if(nums[left]+nums[right] == target){
                res.push_back({nums[left], nums[right]});
                ++left;
                --right;
            }
            else if(nums[left]+nums[right] > target){
                --right;
            }
            else{
                ++left;
            }
        }
        return res;
    }
};
执行耗时:96 ms,击败了53.47% 的C++用户      
内存消耗:44.8 MB,击败了46.95% 的C++用户
```

3.1. 两数之和          
思路: 暴力
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        for(int i=0; i<n; i++){
            for(int j=i+1; j<n; j++){
                if(nums[i]+nums[j] == target)
                    return {i, j};
            }
        }
        return {};
    }
};
执行耗时:284 ms,击败了29.11% 的C++用户       
内存消耗:9.9 MB,击败了70.62% 的C++用户       
```

思路: 哈希
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> umap;
        umap.clear();
        for(int i=0; i<nums.size(); i++){
            auto iter = umap.find(target-nums[i]);
            if(iter != umap.end())
                return {iter->second, i};
            umap[nums[i]] = i;
        }
        return {};
    }
};
执行耗时:12 ms,击败了61.81% 的C++用户      
内存消耗:10.4 MB,击败了56.14% 的C++用户       
```

思路: 双指针   
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> numsCopy= nums;
        sort(numsCopy.begin(), numsCopy.end());
        int left=0, right=numsCopy.size()-1;
        while(left < right){
            if(numsCopy[left]+numsCopy[right] == target){
                break;
            }
            else if(numsCopy[left]+numsCopy[right] < target){
                ++left;
            }
            else{
                --right;
            }
        }
        int val1 = numsCopy[left], val2 = numsCopy[right];
        int k=0, l=0, count=0;
        for(int i=0; i<nums.size(); i++){
            if(val1 == nums[i]){
                if(count == 0){
                    k = i;
                }
                ++count;
            }
            if(val2 == nums[i]){
                l = i;
            }
        }
        if(k == l)
            return {};
        return {k, l};
    }
};
执行耗时:8 ms,击败了91.83% 的C++用户       
内存消耗:10.1 MB,击败了59.64% 的C++用户      
```

4.15. 三数之和     
思路:
```c++


```

5.剑指 Offer 21. 调整数组顺序使奇数位于偶数前面     
思路:
```c++


```

6.75. 颜色分类     
思路:
```c++


```

7.283. 移动零已排序未排序指针     
思路:
```c++


```

8.面试题 16.06. 最小差类似合并两个有序数组     
思路:
```c++


```

9.面试题 17.11. 单词距离类似合并两个有序数组  
思路:
```c++


```
___

**滑动窗口**  
1.剑指 Offer 57 - II. 和为s的连续正数序列     
思路:
```c++


```

2.剑指 Offer 48. 最长不含重复字符的子字符串   
思路:
```c++


```

3.438. 找到字符串中所有字母异位词          
思路:
```c++


```

4.76. 最小覆盖子串        
思路:
```c++


```
___

**前缀后缀统计**      
1.53. 最大子序和（例题1）    
思路:
```c++


```
2.121. 买卖股票的最佳时机（例题2）    
思路:
```c++


```
3.238. 除自身以外数组的乘积（例题3）    
思路:
```c++


```
4.面试题 05.03. 翻转数位   
思路:
```c++


```
5.42. 接雨水    
思路:
```c++


```
___


**位运算**    
1.191. 位1的个数（例题1）  
思路:
```c++


```
2.461. 汉明距离（例题2）    
思路:
```c++


```
3.面试题 05.06. 整数转换  
思路:
```c++


```
4.面试题 05.07. 配对交换  
思路:
```c++


```
5.面试题 05.01. 插入  
思路:
```c++


```
6.面试题 17.04. 消失的数字   
思路:
```c++


```
7.剑指 Offer 56 - I. 数组中数字出现的次数  
思路:
```c++


```
8.剑指 Offer 56 - II. 数组中数字出现的次数 II  
思路:
```c++


```
9.面试题 16.01. 交换数字  
思路:
```c++


```
10.231. 2 的幂   
思路:
```c++


```

___


