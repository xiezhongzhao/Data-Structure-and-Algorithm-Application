**编程题**   
1.两数之和    
思路一: 首先将数据中每个元素放入哈希表中，数值作为key, 索引作为value，然后遍历数组查看`target-nums[i]`是否在哈希表中，
并且`target-nums[i]`对应的索引不等于此时索引`i`, 这样就找到了两数之和等于`target`对应的索引。 
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hash;
        vector<int> res(2, -1);
        for (int i = 0; i < nums.size(); i++) {
            hash[nums[i]] = i;
        }

        for (int i = 0; i < nums.size(); i++) {
            if (hash.count(target-nums[i]) > 0 && i != hash[target-nums[i]]) {
                res[0] = hash[target - nums[i]];
                res[1] = i;
            }
        }
        return res;
    }
};
```

思路二: 定义一个哈希表hash(key,value), 首先在遍历数组过程中查询key值`target-num[i]`是否存在, 然后将数组元素插入哈希表中，
避免和自己匹配。    
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hash;
        for(int i=0; i<nums.size(); i++){
            auto it = hash.find(target-nums[i]);
            if(it != hash.end()){
                return {i, it->second};
            }
            hash[nums[i]] = i;
        }
        return {};
    }
};
```
___
2.1108.IP地址无效化     
思路: 遍历字符，遇到`.`，字符串res就加上`"[.]"`，其余情况不变。  
```c++
class Solution {
public:
    string defangIPaddr(string address) {
        string res;
        for(auto it:address){
            if(it == '.'){
                res += "[.]";
            }else{
                res += it;
            }
        }
        return res;
    }
};
```

3.344.反转字符串  
思路: 定义两个指针一个头部left和一个尾部right，然后头部指针向后走，尾部指针向前走，交换两个指针对应的值，
直到两个指针相遇就表示完成字符串的反转。  
```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left=0, right=s.size()-1;
        while(left < right){
            swap(s[left], s[right]);
            left++;
            right--;
        }
    }
};
```

4.剑指offer58 翻转单词顺序   
思路: 先将子串提取出来存入res容器，然后反转res容器的元素（子串）顺序，最后将容器中元素（子串）进行连接起来。
```c++
class Solution {
public:
    string reverseWords(string s) {
        if(s.empty())
            return "";

        s += " "; //防止最后一个子串漏掉
        string tmp = "";
        vector<string> res;
        for(char ch : s){
            if(ch == ' '){
                if(!tmp.empty()){
                    res.push_back(tmp);
                    tmp.clear();
                }
            }else{
                tmp += ch;
            }
        }
        s.clear();
        reverse(res.begin(), res.end());
        for(auto& str:res){
            s += str + ' ';
        }
        s.pop_back();
        return s;
    }
};
```

5.125.验证回文串   
思路: 首先将字母全部转化为小写字母，然后通过左右指针比较数值，只要出现不相等情况，直接返回false.
```c++
class Solution {
public:
    bool isPalindrome(string str) {
        string s = "";
        for(char c : str){
            if(isalnum(c)){ //isalpha(c) || isdigit(c)
                char tmp = c;
                if(isalpha(c) && c >= 'A' && c <= 'Z')
                    tmp = c + 32;
                s += tmp;
            }
        }

        int left=0, right=s.length()-1;
        while(left < right){
            if(s[left] != s[right]){
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
};


```

6.9.回文数   
思路：将数字转化为字符串，然后通过双指针去判断首尾数值是否相等，只要出现不相等，直接返回false 
```c++
class Solution {
public:
    bool isPalindrome(int x) {
        if(x<0)
            return false;
        string str = "";
        while(x){
            str += x%10 + '0';
            x /= 10;
        }

        int left=0, right=str.length()-1;
        while(left<right){
            if(str[left] != str[right]){
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
};

```

7.58.最后一个单词的长度  
思路: 将字符串前后加入空格`" "`，然后从字符串尾部开始向前遍历，检测到第一个字符串即为最后一个单词的长度。
```c++
class Solution {
public:
    int lengthOfLastWord(string s) {
        s += " ";
        s.insert(0, 1, ' ');
        string tmp;
        vector<string> res;

        int length = s.length();
        for(int i=length-1; i>=0; i--){
            if(s[i] == ' '){
                if(!tmp.empty()){
                    return tmp.length();
                }
            }
            else{
                tmp += s[i];
            }
        }
        return 0;
    }
};


```

8.剑指offer05 替换空格 
思路: 首先定义一个空字符串`res`, 遍历字符串当遇到字符为`' '`加入空格后添加`"%20"`, 其他字符不变，最后得到替换后的字符串。  
```c++
class Solution {
public:
    string replaceSpace(string s) {
        string res;
        for(char c:s){
            if(c == ' '){
                res += "%20";
            }else{
                res += c;
            }
        }
        return res;
    }
};


```

9.剑指offer58 左旋转字符串   
思路: 首先定义一个空字符串，然后添加第`n`个字符之后的字符串，再添加`0-n`之间的字符，最后返回结果。  
```c++
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        string res = "";
        for(int i=n; i<s.length(); i++){
            res += s[i];
        }
        for(int i=0; i<n; i++){
            res += s[i];
        }
        return res;
    }
};
```

10.26.删除排序数组中的重复项    
思路: 采用map存储容器的值以及出现的个数
```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        map<int,int> mp;
        for(int i=0; i<nums.size(); i++){
            mp[nums[i]]++;
        }

        int count=0;
        for(auto it : map){
            nums[count] = it.first;
            count++;
        }
        return count;

    }
};
```

11.剑指offer67 把字符串转换成整数   
思路: 无（该题目需要反复重做，复习）。     
```c++
class Solution {
public:

    int strToInt(string str) {

        int border=INT_MAX/10;
        //1、去除空格
        int i=0;
        while(i<str.size()&&str[i]==' ')
            i++;

        //2、判断符号 并定位第一个数字的位置
        bool sign=0;
        if(str[i]=='-') sign=1;
        if(str[i]=='-'||str[i]=='+')  ++i;

        //3、开始数字拼接  注意遇到字母直接break
        int ans=0;
        for(int j=i;j<str.size();++j){
            if(!isdigit(str[j]))    //——字母
                break;
            else if(j==i)           //——第一个数字
                ans=str[j]-'0';
            else{                   //——后面连续数字
                //4、判断是否出界
                if(ans>border|| (ans==border && str[j]>'7'))
                    return sign?INT_MIN:INT_MAX;
                //！！！这里注意先作str[j]-'0'  不然直接加ASCI码出界报错
                ans=ans*10+(str[j]-'0');
            }
        }

        //5、根据符号判断返回值为正数还是负数
        return sign?ans*-1:ans;
    }
};


```
___

**规律题**   
1.面试题01.08.零矩阵       
思路: 首先找出零元素所在的行和列，然后将所在行和列置为零即可
```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {

        int rows = matrix.size();
        int cols = matrix[0].size();
        vector<pair<int,int>> records;
        for(int i=0; i<rows; i++){
            for(int j=0; j<cols; j++){
                if(matrix[i][j] == 0){
                    records.push_back(make_pair(i,j));
                }
            }
        }

        for(auto it : records) {
            int row = it.first, col = it.second;
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < cols; j++) {
                    matrix[row][j] = 0;
                    matrix[i][col] = 0;
                }
            }
        }
    }
};

执行耗时:52 ms,击败了14.19% 的C++用户   
内存消耗:11.8 MB,击败了54.73% 的C++用户    
```

2.剑指offer61. 扑克牌中的顺子       
思路: 首先将数据从小到大排序，遍历数组得到0元素的个数`zeroNum`，将非零元素用`arr`储存，然后遍历非零元素`arr`
统计相邻元素之差的和`sum`（如果相邻元素相等，直接返回`false`），由于顺子的相邻元素为1，因此相邻元素之差的和`sum`，
顺子相邻元素之差的和`arr.size()-1`,这两者之差`sum-（arr.size()-1）`少于0元素的个数，就可以构成顺子返回`true`。
那么就返回`true`

```c++
class Solution {
public:
    bool isStraight(vector<int>& nums) {
        sort(nums.begin(), nums.end());

        vector<int> arr;
        int zeroNum = 0;

        for(auto it : nums){
            if(it != 0){
                arr.push_back(it);
            }else{
                zeroNum++;
            }
        }

        int sum = 0;
        for(int i=1; i<arr.size(); i++){
            if(arr[i] == arr[i-1])
                return false;
            sum += arr[i]-arr[i-1];
        }
        if(sum - (arr.size()-1) <= zeroNum){
            return true;
        }else{
            return false;
        }

        return false;
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户    
内存消耗:9.9 MB,击败了48.40% 的C++用户   

```

3.面试题16.11.跳水板          
思路: 首先`k`块木板对于短木板有`k+1`种选择`(0,1,...,k)`，然后生成跳水板所有可能的长度可以表示为`shorter*i+longer*(k-i)`，
最后对所有可能长度进行去重。
```c++
class Solution {
public:
    vector<int> divingBoard(int shorter, int longer, int k) {
        set<int> res;
        vector<int> ans;
        if(k == 0)
            return {};

        for(int i=k; i>=0; i--){
            res.insert(shorter*i+longer*(k-i)); //从小到大排列
        }

        for(auto it:res){
            ans.push_back(it);
        }
        return ans;
    }
};
执行耗时:84 ms,击败了10.17% 的C++用户    
内存消耗:37.7 MB,击败了5.00% 的C++用户    
```

4.面试题01.05.一次编辑       
思路:
```c++
class Solution {
public:
    bool oneEditAway(string first, string second) {
        int len1 = first.length();
        int len2 = second.length();
        if(len1 == 0 && len2 == 0)
            return true;

        if(abs(len1-len2) > 1)
            return false;

        if(len1 > len2){
            for(int i=0; i<len1; i++){
                string choice = "";
                for(int j=0; j<len1; j++){
                    if(i == j)
                        continue;
                    choice +=  first[j];
                }
                if(choice == second)
                    return true;

            }
            
        }else if(len1 < len2){
            for(int i=0; i<len2; i++){
                string choice = "";
                for(int j=0; j<len2; j++){
                    if(i == j)
                        continue;
                    choice +=  second[j];
                }
                if(choice == first)
                    return true;
            }
        }
        else{
            int equalNum = 0;
            for(int i=0; i<len1; i++){
                if(first[i] == second[i]){
                    ++equalNum;
                }
            }
            if(equalNum >= len1-1)
                return true;
        }
        return false;
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户    
内存消耗:6.1 MB,击败了40.61% 的C++用户         
```

5.面试题16.15.珠玑妙算       
思路: 首先用两个哈希表统计`solution`和`guess`每个元素的个数，然后统计两个哈希表中相同的元素对应的个数（较少的）之和`pseudoNum`，
最后统计位置和颜色完全的数量`rightNum`，颜色正确位置不正确的数量为`pseudoNum-rightNum`。
```c++
class Solution {
public:
    vector<int> masterMind(string solution, string guess) {
        vector<int> res;
        int len = solution.length();
        int rightNum = 0;
        int pseudoNum = 0;

        unordered_map<char,int> hash1, hash2;
        for(int i=0; i<len; i++){
            hash1[solution[i]]++;
            hash2[guess[i]]++;
        }
        for(auto it1:hash1){
            for(auto it2:hash2){
                if(it1.first == it2.first){
                    pseudoNum += it1.second>=it2.second ? it2.second : it1.second;
                }
            }
        }

        for(int i=0; i<len; i++){
            if(solution[i] == guess[i]){
                ++rightNum;
                continue;
            }
        }
        res.push_back(rightNum);
        res.push_back(pseudoNum-rightNum);
        
        return res;
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户
内存消耗:6.1 MB,击败了5.54% 的C++用户
```

6.面试题16.04.井字游戏         
思路: 
```c++


```

7.55.跳跃游戏       
思路:
```c++


```

8.48.旋转图像       
思路:
```c++


```

9.54.旋转矩阵       
思路:
```c++


```

10.搜索二维矩阵II      
思路: 选取二维矩阵右上角的元素为参考值，`target`大于参考值，则`target`在参考值的下方，反之，`target`在参考值的左边，
如果相等则表示找到`target`，返回`true`。
```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {

        int rows = matrix.size();
        int cols = matrix[0].size();

        int startRow = 0;
        int startCol = cols-1;
        while(startRow<rows && startCol>=0){
            if(target > matrix[startRow][startCol]){
                startRow++;
            }else if(target < matrix[startRow][startCol]){
                startCol--;
            }else{
                return true;
            }
        }
        return false;
    }
};
执行耗时:76 ms,击败了94.32% 的C++用户
内存消耗:14.4 MB,击败了64.05% 的C++用户

```
___

