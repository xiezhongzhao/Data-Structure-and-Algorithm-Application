**编程题**   
1.两数之和    
思路一: 首先将数据中每个元素放入哈希表中，数值作为key, 索引作为value，然后遍历数组查看`target-nums[i]`是否在哈希表中，
并且`target-nums[i]`对应的索引不等于此时索引`i`, 这样就找到了两数之和等于`target`对应的索引。 
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hash;
        vector<int> res(2, -1);
        for (int i = 0; i < nums.size(); i++) {
            hash[nums[i]] = i;
        }

        for (int i = 0; i < nums.size(); i++) {
            if (hash.count(target-nums[i]) > 0 && i != hash[target-nums[i]]) {
                res[0] = hash[target - nums[i]];
                res[1] = i;
            }
        }
        return res;
    }
};
```

思路二: 定义一个哈希表hash(key,value), 首先在遍历数组过程中查询key值`target-num[i]`是否存在, 然后将数组元素插入哈希表中，
避免和自己匹配。    
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hash;
        for(int i=0; i<nums.size(); i++){
            auto it = hash.find(target-nums[i]);
            if(it != hash.end()){
                return {i, it->second};
            }
            hash[nums[i]] = i;
        }
        return {};
    }
};
```
___
2.1108.IP地址无效化     
思路: 遍历字符，遇到`.`，字符串res就加上`"[.]"`，其余情况不变。  
```c++
class Solution {
public:
    string defangIPaddr(string address) {
        string res;
        for(auto it:address){
            if(it == '.'){
                res += "[.]";
            }else{
                res += it;
            }
        }
        return res;
    }
};
```

3.344.反转字符串  
思路: 定义两个指针一个头部left和一个尾部right，然后头部指针向后走，尾部指针向前走，交换两个指针对应的值，
直到两个指针相遇就表示完成字符串的反转。  
```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left=0, right=s.size()-1;
        while(left < right){
            swap(s[left], s[right]);
            left++;
            right--;
        }
    }
};
```

4.剑指offer58 翻转单词顺序   
思路: 先将子串提取出来存入res容器，然后反转res容器的元素（子串）顺序，最后将容器中元素（子串）进行连接起来。
```c++
class Solution {
public:
    string reverseWords(string s) {
        if(s.empty())
            return "";

        s += " "; //防止最后一个子串漏掉
        string tmp = "";
        vector<string> res;
        for(char ch : s){
            if(ch == ' '){
                if(!tmp.empty()){
                    res.push_back(tmp);
                    tmp.clear();
                }
            }else{
                tmp += ch;
            }
        }
        s.clear();
        reverse(res.begin(), res.end());
        for(auto& str:res){
            s += str + ' ';
        }
        s.pop_back();
        return s;
    }
};
```

5.125.验证回文串   
思路: 首先将字母全部转化为小写字母，然后通过左右指针比较数值，只要出现不相等情况，直接返回false.
```c++
class Solution {
public:
    bool isPalindrome(string str) {
        string s = "";
        for(char c : str){
            if(isalnum(c)){ //isalpha(c) || isdigit(c)
                char tmp = c;
                if(isalpha(c) && c >= 'A' && c <= 'Z')
                    tmp = c + 32;
                s += tmp;
            }
        }

        int left=0, right=s.length()-1;
        while(left < right){
            if(s[left] != s[right]){
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
};


```

6.9.回文数   
思路：将数字转化为字符串，然后通过双指针去判断首尾数值是否相等，只要出现不相等，直接返回false 
```c++
class Solution {
public:
    bool isPalindrome(int x) {
        if(x<0)
            return false;
        string str = "";
        while(x){
            str += x%10 + '0';
            x /= 10;
        }

        int left=0, right=str.length()-1;
        while(left<right){
            if(str[left] != str[right]){
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
};

```

7.58.最后一个单词的长度  
思路: 将字符串前后加入空格`" "`，然后从字符串尾部开始向前遍历，检测到第一个字符串即为最后一个单词的长度。
```c++
class Solution {
public:
    int lengthOfLastWord(string s) {
        s += " ";
        s.insert(0, 1, ' ');
        string tmp;
        vector<string> res;

        int length = s.length();
        for(int i=length-1; i>=0; i--){
            if(s[i] == ' '){
                if(!tmp.empty()){
                    return tmp.length();
                }
            }
            else{
                tmp += s[i];
            }
        }
        return 0;
    }
};


```

8.剑指offer05 替换空格 
思路: 首先定义一个空字符串`res`, 遍历字符串当遇到字符为`' '`加入空格后添加`"%20"`, 其他字符不变，最后得到替换后的字符串。  
```c++
class Solution {
public:
    string replaceSpace(string s) {
        string res;
        for(char c:s){
            if(c == ' '){
                res += "%20";
            }else{
                res += c;
            }
        }
        return res;
    }
};


```

9.剑指offer58 左旋转字符串   
思路: 首先定义一个空字符串，然后添加第`n`个字符之后的字符串，再添加`0-n`之间的字符，最后返回结果。  
```c++
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        string res = "";
        for(int i=n; i<s.length(); i++){
            res += s[i];
        }
        for(int i=0; i<n; i++){
            res += s[i];
        }
        return res;
    }
};
```

10.26.删除排序数组中的重复项    
思路: 采用map存储容器的值以及出现的个数
```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        map<int,int> mp;
        for(int i=0; i<nums.size(); i++){
            mp[nums[i]]++;
        }

        int count=0;
        for(auto it : map){
            nums[count] = it.first;
            count++;
        }
        return count;

    }
};
```

11.剑指offer67 把字符串转换成整数   
思路: 无（该题目需要反复重做，复习）。     
```c++
class Solution {
public:

    int strToInt(string str) {

        int border=INT_MAX/10;
        //1、去除空格
        int i=0;
        while(i<str.size()&&str[i]==' ')
            i++;

        //2、判断符号 并定位第一个数字的位置
        bool sign=0;
        if(str[i]=='-') sign=1;
        if(str[i]=='-'||str[i]=='+')  ++i;

        //3、开始数字拼接  注意遇到字母直接break
        int ans=0;
        for(int j=i;j<str.size();++j){
            if(!isdigit(str[j]))    //——字母
                break;
            else if(j==i)           //——第一个数字
                ans=str[j]-'0';
            else{                   //——后面连续数字
                //4、判断是否出界
                if(ans>border|| (ans==border && str[j]>'7'))
                    return sign?INT_MIN:INT_MAX;
                //！！！这里注意先作str[j]-'0'  不然直接加ASCI码出界报错
                ans=ans*10+(str[j]-'0');
            }
        }

        //5、根据符号判断返回值为正数还是负数
        return sign?ans*-1:ans;
    }
};


```
___

**规律题**   
1.面试题01.08.零矩阵       
思路: 
```c++


```

2.剑指offer61. 扑克牌中的顺子       
思路:
```c++


```

3.面试题16.11.跳水板          
思路:
```c++


```

4.面试题01.05.一次编辑       
思路:
```c++


```

5.面试题16.15.珠玑妙算       
思路:
```c++


```

6.面试题16.04.井字游戏       
思路:
```c++


```

7.55.跳跃游戏       
思路:
```c++


```

8.48.旋转图像       
思路:
```c++


```

9.54.旋转矩阵       
思路:
```c++


```

10.搜索二维矩阵II      
思路:
```c++


```
___

