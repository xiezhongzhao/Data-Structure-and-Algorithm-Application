**编程题**
1.两数之和    
思路一: 首先将数据中每个元素放入哈希表中，数值作为key, 索引作为value，然后遍历数组查看`target-nums[i]`是否在哈希表中，
并且`target-nums[i]`对应的索引不等于此时索引`i`, 这样就找到了两数之和等于`target`对应的索引。 
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hash;
        vector<int> res(2, -1);
        for (int i = 0; i < nums.size(); i++) {
            hash[nums[i]] = i;
        }

        for (int i = 0; i < nums.size(); i++) {
            if (hash.count(target-nums[i]) > 0 && i != hash[target-nums[i]]) {
                res[0] = hash[target - nums[i]];
                res[1] = i;
            }
        }
        return res;
    }
};
```

思路二: 定义一个哈希表hash(key,value), 首先在遍历数组过程中查询key值`target-num[i]`是否存在, 然后将数组元素插入哈希表中，
避免和自己匹配。    
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hash;
        for(int i=0; i<nums.size(); i++){
            auto it = hash.find(target-nums[i]);
            if(it != hash.end()){
                return {i, it->second};
            }
            hash[nums[i]] = i;
        }
        return {};
    }
};
```
___
2.1108.IP地址无效化     
思路: 遍历字符，遇到`.`，字符串res就加上`"[.]"`，其余情况不变。  
```c++
class Solution {
public:
    string defangIPaddr(string address) {
        string res;
        for(auto it:address){
            if(it == '.'){
                res += "[.]";
            }else{
                res += it;
            }
        }
        return res;
    }
};
```

3.344.反转字符串  
思路: 定义两个指针一个头部left和一个尾部right，然后头部指针向后走，尾部指针向前走，交换两个指针对应的值，
直到两个指针相遇就表示完成字符串的反转。  
```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left=0, right=s.size()-1;
        while(left < right){
            swap(s[left], s[right]);
            left++;
            right--;
        }
    }
};
```

4.剑指offer58 翻转单词顺序   
思路: 先将子串提取出来存入res容器，然后反转res容器的元素（子串）顺序，最后将容器中元素（子串）进行连接起来。
```c++
class Solution {
public:
    string reverseWords(string s) {
        if(s.empty())
            return "";

        s += " "; //防止最后一个子串漏掉
        string tmp = "";
        vector<string> res;
        for(char ch : s){
            if(ch == ' '){
                if(!tmp.empty()){
                    res.push_back(tmp);
                    tmp.clear();
                }
            }else{
                tmp += ch;
            }
        }
        s.clear();
        reverse(res.begin(), res.end());
        for(auto& str:res){
            s += str + ' ';
        }
        s.pop_back();
        return s;
    }
};
```

5.125.验证回文串   
思路: 首先将字母全部转化为小写字母，然后通过左右指针比较数值，只要出现不相等情况，直接返回false.
```c++
class Solution {
public:
    bool isPalindrome(string str) {
        string s = "";
        for(char c : str){
            if(isalnum(c)){ //isalpha(c) || isdigit(c)
                char tmp = c;
                if(isalpha(c) && c >= 'A' && c <= 'Z')
                    tmp = c + 32;
                s += tmp;
            }
        }

        int left=0, right=s.length()-1;
        while(left < right){
            if(s[left] != s[right]){
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
};


```

6.9.回文数   
思路：将数字转化为字符串，然后通过双指针去判断首尾数值是否相等，只要出现不相等，直接返回false 
```c++
class Solution {
public:
    bool isPalindrome(int x) {
        if(x<0)
            return false;
        string str = "";
        while(x){
            str += x%10 + '0';
            x /= 10;
        }

        int left=0, right=str.length()-1;
        while(left<right){
            if(str[left] != str[right]){
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
};

```

7.58.最后一个单词的长度  
思路: 将字符串前后加入空格`" "`，然后从字符串尾部开始向前遍历，检测到第一个字符串即为最后一个单词的长度。
```c++
class Solution {
public:
    int lengthOfLastWord(string s) {
        s += " ";
        s.insert(0, 1, ' ');
        string tmp;
        vector<string> res;

        int length = s.length();
        for(int i=length-1; i>=0; i--){
            if(s[i] == ' '){
                if(!tmp.empty()){
                    return tmp.length();
                }
            }
            else{
                tmp += s[i];
            }
        }
        return 0;
    }
};


```

8.剑指offer05 替换空格 
思路: 首先定义一个空字符串`res`, 遍历字符串当遇到字符为`' '`加入空格后添加`"%20"`, 其他字符不变，最后得到替换后的字符串。  
```c++
class Solution {
public:
    string replaceSpace(string s) {
        string res;
        for(char c:s){
            if(c == ' '){
                res += "%20";
            }else{
                res += c;
            }
        }
        return res;
    }
};


```

9.剑指offer58 左旋转字符串   
思路: 首先定义一个空字符串，然后添加第`n`个字符之后的字符串，再添加`0-n`之间的字符，最后返回结果。  
```c++
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        string res = "";
        for(int i=n; i<s.length(); i++){
            res += s[i];
        }
        for(int i=0; i<n; i++){
            res += s[i];
        }
        return res;
    }
};
```

10.26.删除排序数组中的重复项    
思路:   
```c++



```

11.剑指offer67 把字符串转换成整数   
思路:     
```c++



```
___

**规律题**


