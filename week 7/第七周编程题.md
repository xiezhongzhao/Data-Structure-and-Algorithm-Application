**LCA最近公共祖先**     
1.236. **二叉树的最近公共祖先**    
思路:
```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr || root == p || root == q)
            return root;

        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);

        if(left != nullptr)
            cout << "left: " << left->val << endl;
        if(right != nullptr)
            cout << "right: " << right->val << endl;

        if(left == nullptr){
            return right;
        }
        if(right == nullptr){
            return left;
        }

        return root;
    }
};
执行耗时:12 ms,击败了93.67% 的C++用户   
内存消耗:13.9 MB,击败了47.26% 的C++用户      
```

2.剑指 Offer 68 - I. 二叉搜索树的最近公共祖先  
思路:
```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr)
            return nullptr;
        if(root == p || root == q)
            return root;

        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if(left == nullptr)
            return right;
        if(right == nullptr)
            return left;
        return root;
    }
};
执行耗时:28 ms,击败了68.07% 的C++用户
内存消耗:22.7 MB,击败了73.59% 的C++用户
```

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr)
            return nullptr;

        if(root->val > p->val && root->val > q->val)
            return lowestCommonAncestor(root->left, p, q);
        if(root->val < p->val && root->val < q->val)
            return lowestCommonAncestor(root->right, p, q);
        return root;
    }
};
执行耗时:24 ms,击败了91.09% 的C++用户     
内存消耗:22.5 MB,击败了99.76% 的C++用户    

```
___


**二叉树转单、双、循环链表**   
1.114. **二叉树展开为链表**   
思路:
```c++
class Solution {
public:
    TreeNode* last = nullptr;
    void flatten(TreeNode* root) {
        if(root == nullptr)
            return ;
        flatten(root->right);
        flatten(root->left);

        root->right = last;
        root->left = nullptr;
        last = root;
    }
};
执行耗时:8 ms,击败了39.62% 的C++用户
内存消耗:12.3 MB,击败了77.61% 的C++用户
```

2.面试题 17.12. BiNode   
思路:
```c++
class Solution {
public:
    TreeNode* res = new TreeNode(-1);
    TreeNode* tmp = res;
    TreeNode* convertBiNode(TreeNode* root) {
        if(root == nullptr)
            return nullptr;

        convertBiNode(root->left);
        tmp->right = root;
        root->left = nullptr;
        tmp = tmp->right;
        convertBiNode(root->right);

        return res->right;
    }
};
执行耗时:52 ms,击败了75.51% 的C++用户 
内存消耗:30.6 MB,击败了94.97% 的C++用户

```

3.剑指 Offer 36. **二叉搜索树与双向链表**   
思路:
```c++
class Solution {
public:
    Node *pre, *head;
    void dfs(Node* root){
        if(root == nullptr)
            return ;
        dfs(root->left);
        if(pre != nullptr)
            pre->right = root;
        else
            head = root;
        root->left = pre;
        pre = root;
        dfs(root->right);
    }

    Node* treeToDoublyList(Node* root) {
        if(root == nullptr)
            return nullptr;
        dfs(root);
        head->left = pre;
        pre->right = head;
        return head;
    }
};
执行耗时:4 ms,击败了92.78% 的C++用户   
内存消耗:7.4 MB,击败了55.16% 的C++用户     
```

4.面试题 04.03. 特定深度节点链表  
思路:
```c++
class Solution {
public:
    vector<ListNode*> listOfDepth(TreeNode* tree) {
        vector<ListNode*> res;
        if(tree == nullptr)
            return res;

        queue<TreeNode*> q;
        q.push(tree);
        while(!q.empty()){
            ListNode* dummy = new ListNode(-1);
            ListNode* head = dummy;
            int n = q.size();
            for(int i=0; i<n; i++){
                TreeNode* tmp = q.front();
                q.pop();

                head->next = new ListNode(tmp->val);
                head = head->next;
                if(tmp->left != nullptr)
                    q.push(tmp->left);
                if(tmp->right != nullptr)
                    q.push(tmp->right);
            }
            head->next = nullptr;
            res.push_back(dummy->next);
        }
        return res;
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户     
内存消耗:7.8 MB,击败了80.25% 的C++用户       

```
___

**按照遍历结果反向构建二叉树**   
1.105. 从前序与中序遍历序列构造二叉树   
思路:
```c++


```

2.889. 根据前序和后序遍历构造二叉树  
思路:
```c++


```

3.106. 从中序与后序遍历序列构造二叉树     
思路:
```c++


```

4.剑指 Offer 33. 二叉搜索树的后序遍历序列   
思路:
```c++


```
___

**二叉树上的最长路径和**   
1.543. 二叉树的直径   
思路:
```c++


```

2.剑指 Offer 34. 二叉树中和为某一值的路径   
思路:
```c++


```

3.124. 二叉树中的最大路径和   
思路:
```c++


```
4.剑指offer II 051. 节点之和最大的路径   
思路:
```c++


```

___

**Trie+堆**   
1.23. 合并K个升序链表   
思路:
```c++


```

2.347. 前 K 个高频元素   
思路:
```c++


```

3.295. 数据流的中位数   
思路:
```c++


```

4.973. 最接近原点的 K 个点   
思路:
```c++


```

5.208. 实现 Trie (前缀树)   
思路:
```c++


```

6.面试题 17.17. 多次搜索   
思路:
```c++


```

7.212. 单词搜索 II   
思路:
```c++


```
