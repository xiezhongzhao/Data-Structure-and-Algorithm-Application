**LCA最近公共祖先**     
1.236. **二叉树的最近公共祖先**    
思路: 利用后序遍历，左节点->右节点->根节点，然后在遍历过程中如果根节点为空或者等于两个节点p,q，则直接返回根节点，
此时的根节点为最近公共祖先，如果左节点为空，那么遍历右节点，如果右节点为空，那么遍历左节点。
```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr || root == p || root == q)
            return root;

        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);

        if(left != nullptr)
            cout << "left: " << left->val << endl;
        if(right != nullptr)
            cout << "right: " << right->val << endl;

        if(left == nullptr){
            return right;
        }
        if(right == nullptr){
            return left;
        }

        return root;
    }
};
执行耗时:12 ms,击败了93.67% 的C++用户   
内存消耗:13.9 MB,击败了47.26% 的C++用户      
```

2.剑指 Offer 68 - I. 二叉搜索树的最近公共祖先  
思路: 与上题思路移植（没有利用二叉搜索树的性质） 
```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr)
            return nullptr;
        if(root == p || root == q)
            return root;

        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if(left == nullptr)
            return right;
        if(right == nullptr)
            return left;
        return root;
    }
};
执行耗时:28 ms,击败了68.07% 的C++用户
内存消耗:22.7 MB,击败了73.59% 的C++用户
```

思路: 二叉搜索树的性质，左节点小于根节点，根节点小于右节点，那么与上题思路相似，先确定返回条件，
如果根节点为空节点，直接返回空节点，然后利用二叉搜索树的性质，如果根节点都大于p,q，直接遍历左子树，
如果根节点都小于p,q， 直接遍历右子树，其他情况，直接返回根节点。
```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr)
            return nullptr;

        if(root->val > p->val && root->val > q->val)
            return lowestCommonAncestor(root->left, p, q);
        if(root->val < p->val && root->val < q->val)
            return lowestCommonAncestor(root->right, p, q);
        return root;
    }
};
执行耗时:24 ms,击败了91.09% 的C++用户     
内存消耗:22.5 MB,击败了99.76% 的C++用户    

```
___


**二叉树转单、双、循环链表**   
1.114. **二叉树展开为链表**   
思路: 先遍历右子树再遍历左子树，然后将右节点指向上一个节点last（初始值为nullptr），并且将左节点置为nullptr,
最后更新上一个节点last为root节点。   
```c++
class Solution {
public:
    TreeNode* last = nullptr;
    void flatten(TreeNode* root) {
        if(root == nullptr)
            return ;
        flatten(root->right);
        flatten(root->left);

        root->right = last;
        root->left = nullptr;
        last = root;
    }
};
执行耗时:8 ms,击败了39.62% 的C++用户
内存消耗:12.3 MB,击败了77.61% 的C++用户
```

2.面试题 17.12. BiNode   
思路: 中序遍历
```c++
class Solution {
public:
    TreeNode* res = new TreeNode(-1);
    TreeNode* tmp = res;
    TreeNode* convertBiNode(TreeNode* root) {
        if(root == nullptr)
            return nullptr;

        convertBiNode(root->left);
        tmp->right = root;
        root->left = nullptr;
        tmp = tmp->right;
        convertBiNode(root->right);

        return res->right;
    }
};
执行耗时:52 ms,击败了75.51% 的C++用户 
内存消耗:30.6 MB,击败了94.97% 的C++用户

```

3.剑指 Offer 36. **二叉搜索树与双向链表**   
思路: 利用中序遍历，首先定义头节点head和上一个节点pre，然后开始进行中序遍历，pre为空，此时记录头节点head，
如果pre不为空，则将pre的右指针指向当前节点，再将当前节点的左指针指向上一个节点，形成双向链表，最后将pre节点
更新为当前节点。
```c++
class Solution {
public:
    Node *pre, *head;
    void dfs(Node* root){
        if(root == nullptr)
            return ;
        dfs(root->left);
        if(pre != nullptr) //让上一个节点的右指针指向当前节点
            pre->right = root;
        else
            head = root; //如果pre为空，就说明是第一个节点，头节点，head保存头节点
        
        root->left = pre; //当前节点的左指针指向上一个节点，形成双向链表 
        
        pre = root;//将当前节点保存为上一个节点
        dfs(root->right);
    }

    Node* treeToDoublyList(Node* root) {
        if(root == nullptr)
            return nullptr;
        dfs(root);
        head->left = pre;
        pre->right = head;
        
        return head;
    }
};
执行耗时:4 ms,击败了92.78% 的C++用户   
内存消耗:7.4 MB,击败了55.16% 的C++用户     
```

4.面试题 04.03. 特定深度节点链表  
思路: 层序遍历
```c++
class Solution {
public:
    vector<ListNode*> listOfDepth(TreeNode* tree) {
        vector<ListNode*> res;
        if(tree == nullptr)
            return res;

        queue<TreeNode*> q;
        q.push(tree);
        while(!q.empty()){
            ListNode* dummy = new ListNode(-1);
            ListNode* head = dummy;
            int n = q.size();
            for(int i=0; i<n; i++){
                TreeNode* tmp = q.front();
                q.pop();

                head->next = new ListNode(tmp->val);
                head = head->next;
                if(tmp->left != nullptr)
                    q.push(tmp->left);
                if(tmp->right != nullptr)
                    q.push(tmp->right);
            }
            head->next = nullptr;
            res.push_back(dummy->next);
        }
        return res;
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户     
内存消耗:7.8 MB,击败了80.25% 的C++用户       

```
___

**按照遍历结果反向构建二叉树**   
1.105. 从前序与中序遍历序列构造二叉树   
思路:
```c++


```

2.889. 根据前序和后序遍历构造二叉树  
思路:
```c++


```

3.106. 从中序与后序遍历序列构造二叉树     
思路:
```c++


```

4.剑指 Offer 33. 二叉搜索树的后序遍历序列   
思路:
```c++


```
___

**二叉树上的最长路径和**   
1.543. 二叉树的直径   
思路: 计算左子树和右子树的高度，然后将两个高度相加
```c++
class Solution {
public:
    int maxVal=INT_MIN;
    int dfs(TreeNode* root){
        if(root == nullptr)
            return 0;

        int leftHeight = dfs(root->left);
        int rightHeight= dfs(root->right);
        maxVal = max(maxVal, rightHeight+leftHeight);

        return max(leftHeight, rightHeight)+1;
    }

    int diameterOfBinaryTree(TreeNode* root) {
        dfs(root);
        return maxVal;
    }
};
执行耗时:8 ms,击败了73.97% 的C++用户 
内存消耗:19.6 MB,击败了98.69% 的C++用户

```

2.剑指 Offer 34. 二叉树中和为某一值的路径   
思路: 先统计二叉树的所有的路径，然后计算路径和，最后与目标值进行对比。    
```c++
class Solution {
public:
    vector<int> path;
    int sum(vector<int>& path){
        int s = 0;
        for(auto it : path){
            s += it;
        }
        return s;
    }

    void dfs(TreeNode* root, vector<vector<int>>& ans, int target){
        path.push_back(root->val);
        if(root->left == nullptr && root->right == nullptr){
            if(sum(path) == target)
                ans.push_back(path);
            return ;
        }
        if(root->left){
            dfs(root->left, ans, target);
            path.pop_back();
        }
        if(root->right){
            dfs(root->right, ans, target);
            path.pop_back();
        }
    }

    vector<vector<int>> pathSum(TreeNode* root, int target) {
        vector<vector<int>> ans;
        ans.clear();
        if(root == nullptr)
            return ans;
        dfs(root, ans, target);
        return ans;
    }
};
执行耗时:8 ms,击败了65.68% 的C++用户
内存消耗:19.1 MB,击败了99.85% 的C++用户
```

3.124. 二叉树中的最大路径和   
思路: 题目可以转化成左节点到根节点到右节点的和的最大值，首先保证左子树,右子树的路径和大于零，然后
计算左右节点和当前节点的和，最后返回
```c++
class Solution {
public:
    int res=INT_MIN;
    int  getMax(TreeNode* root){
        if(root == nullptr)
            return 0;
        int left = max(0, getMax(root->left));
        int right = max(0, getMax(root->right));
        res = max(res, left+right+root->val);
        return max(left, right)+root->val;
    }

    int maxPathSum(TreeNode* root) {
        getMax(root);
        return res;
    }
};
执行耗时:20 ms,击败了80.71% 的C++用户
内存消耗:26.9 MB,击败了89.48% 的C++用户
```

___

**Trie+堆**   
1.23. 合并K个升序链表   
思路:
```c++


```

2.347. 前 K 个高频元素   
思路:
```c++


```

3.295. 数据流的中位数   
思路:
```c++


```

4.973. 最接近原点的 K 个点   
思路:
```c++


```

5.208. 实现 Trie (前缀树)   
思路:
```c++


```

6.面试题 17.17. 多次搜索   
思路:
```c++


```

7.212. 单词搜索 II   
思路:
```c++


```
