[TOC]
#### 1. 斐波拉契数 509
```
class Solution {
public:
    int fib(int n) {
        if(n <= 1)
            return n;

        int dp[n+1];
        memset(dp, 0, sizeof(dp));
        dp[0] = 0;
        dp[1] = 1;
        for(int i=2; i<=n; ++i){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
```

#### 2. 爬楼梯 70
```
class Solution {
public:
    int climbStairs(int n) {
        if(n < 1)
            return 0;

        int dp[n+1];
        memset(dp, 0, sizeof(dp));
        dp[0] = 1;
        dp[1] = 1;
        for(int i=2; i<=n; ++i){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户     
内存消耗:5.9 MB,击败了55.04% 的C++用户      
```


#### 3. 使用最小花费爬楼梯 746
```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int dp[cost.size()];
        memset(dp, 0, sizeof(dp));
        dp[0] = cost[0];
        dp[1] = cost[1];
        for(int i=2; i<cost.size(); ++i){
            dp[i] = cost[i] + min(dp[i-1], dp[i-2]);
        }
        return min(dp[cost.size()-1], dp[cost.size()-2]);
    }
};
执行耗时:8 ms,击败了39.40% 的C++用户    
内存消耗:13.3 MB,击败了79.56% 的C++用户    
```

#### 4. 不同路径 62
```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        if(m<=0 || n<=0)
            return 0;

        int dp[m][n];
        memset(dp, 0, sizeof(dp));
        for(int i=0; i<m; ++i)
            dp[i][0] = 1;
        for(int j=0; j<n; ++j)
            dp[0][j] = 1;

        for(int i=1; i<m; ++i){
            for(int j=1; j<n; ++j){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户     
内存消耗:5.7 MB,击败了99.31% 的C++用户     
```

#### 5. 不同路径 63
```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();

        int dp[m][n];
        memset(dp, 0, sizeof(dp));
        for(int i=0; i<m; ++i){
            if(obstacleGrid[i][0] == 0)
                dp[i][0] = 1;
            else
                break;
        }
        for(int j=0; j<n; ++j){
            if(obstacleGrid[0][j] == 0)
                dp[0][j] = 1;
            else
                break;
        }
        
        for(int i=1; i<m; ++i){
            for(int j=1; j<n; ++j){
                if(obstacleGrid[i][j] == 0)
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户       
内存消耗:7.4 MB,击败了82.69% 的C++用户      
```


#### 6. 整数拆分 343
```c++
class Solution {
public:
    int integerBreak(int n) {
        if(n < 2)
            return 0;
        int dp[n+1];
        memset(dp, 0, sizeof(dp));
        dp[2] = 1;
        for(int i=3; i<=n; ++i){
            for(int j=1; j<=i-1; ++j){
                dp[i] = max(dp[i], max((i-j)*j, dp[i-j]*j));
            }
        }
        return dp[n];
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户     
内存消耗:5.7 MB,击败了97.04% 的C++用户    
```

#### 7. 不同的二叉搜索树 96
```c++
class Solution {
public:
    int numTrees(int n) {
        if(n == 1)
            return 1;
        if(n == 2)
            return 2;

        int dp[n+1];
        memset(dp, 0, sizeof(dp));
        dp[0] = 1;
        dp[1] = 1;
        dp[2] = 2;
        for(int i=3; i<=n; ++i){
            for(int j=i-1; j>=0; --j){
                dp[i] += dp[j] * dp[i-1-j];
            }
        }
        return dp[n];
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户     
内存消耗:5.8 MB,击败了91.75% 的C++用户      
```

#### 8. 分割等和子集 416
```c++



```


#### 9. 最后一块石头的重量II 1049
```c++



```


#### 10. 目标和 494
```c++




```


#### 11. 一和零 474
```c++




```

#### 12. 零钱兑换II 518
```c++



```


#### 13. 组合总和IV 377
```c++



```


#### 14. 爬楼梯 70
```c++



```

#### 15. 零钱兑换 322
```c++



```

#### 16. 完全平方数 279
```c++




```

#### 17. 单词拆分 139
```c++




```

#### 18. 打家劫舍 198
```c++



```

#### 19. 打家劫舍II 213
```c++




```


#### 20. 打家劫舍III 337
```c++




```

#### 21. 买卖股票的最佳时机 I 121
```c++



```

#### 22. 买卖股票的最佳时机 II 122
```c++



```


#### 23. 买卖股票的最佳时机 III 123
```c++




```


#### 24. 买卖股票的最佳时机 IV 188
```c++



```




#### 25. 最佳买卖股票时机含冷冻期 309
```c++




```

#### 26. 买卖股票的最佳时机含手续费 741
```c++



```




#### 27. 最长递增子序列 300
```c++



```


#### 28. 最长连续递增序列 674
```c++



```


#### 29. 最长重复子数组 718
```c++
class Solution {
public:
    // dp[i][j]
    // dp[i][j] = dp[i-1][j-1]
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        vector<vector<int>> dp(nums1.size()+1, vector<int>(nums2.size()+1, 0));
        int res = 0;
        for(int i=1; i<=nums1.size(); ++i){
            for(int j=1; j<=nums2.size(); ++j){
                if(nums1[i-1] == nums2[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }
                if(dp[i][j] > res)
                    res = dp[i][j];
            }
        }
        return res;
    }
};
执行耗时:240 ms,击败了31.25% 的C++用户     
内存消耗:83.6 MB,击败了19.58% 的C++用户        
```



#### 30. 最长公共子序列 1143
```c++




```


#### 31. 不相交的线 1035
```c++



```



#### 32. 最大子序和 53
```c++




```



#### 33. 判断子序列 392
```c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int index = -1;
        int count = 0;
        for(int i=0; i<s.size(); ++i){
            for(int j=index+1; j<t.size(); ++j){
                if(s[i] == t[j]){
                    index = j;
                    ++count;
                    break;
                }
            }
        }
        return count == s.size() ? true : false;
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户       
内存消耗:6.1 MB,击败了96.91% 的C++用户          
```



#### 34. 不同的子序列 115
```c++
class Solution {
public:
    int numDistinct(string s, string t) {
        if(s.size() < t.size())
            return 0;
        vector<vector<uint64_t>> dp(s.size()+1, vector<uint64_t>(t.size()+1, 0));
        for(int i=0; i<s.size(); ++i)
            dp[i][0] = 1;
        for(int i=1; i<=s.size(); i++){
            for(int j=1; j<=t.size(); j++){
                if(s[i-1] == t[j-1]){
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
                }else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[s.size()][t.size()];
    }
};
执行耗时:36 ms,击败了77.40% 的C++用户       
内存消耗:29.4 MB,击败了52.70% 的C++用户            
```

#### 35. 两个字符串的删除操作 583
```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size();
        int n = word2.size();
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
        for(int i=0; i<=m; ++i) dp[i][0] = i;
        for(int j=0; j<=n; ++j) dp[0][j] = j;
        for(int i=1; i<=m; ++i){
            for(int j=1; j<=n; ++j){
                if(word1[i-1] == word2[j-1]){
                    dp[i][j] = dp[i-1][j-1];
                }else{
                    dp[i][j] = 1 + min({dp[i][j-1], dp[i-1][j]});
                }
            }
        }
        return dp[m][n];
    }
};
执行耗时:28 ms,击败了33.49% 的C++用户      
内存消耗:11.9 MB,击败了67.91% 的C++用户             
```

#### 36. 编辑距离 72
```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size();
        int n = word2.size();
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
        for(int i=0; i<=m; ++i) dp[i][0] = i;
        for(int j=0; j<=n; ++j) dp[0][j] = j;
        for(int i=1; i<=m; ++i){
            for(int j=1; j<=n; ++j){
                if(word1[i-1] == word2[j-1]){
                    dp[i][j] = dp[i-1][j-1];
                }else{
                    dp[i][j] = 1 + min({dp[i-1][j-1], dp[i-1][j], dp[i][j-1]});
                }
            }
        }
        return dp[m][n];
    }
};
执行耗时:24 ms,击败了12.65% 的C++用户      
内存消耗:8.9 MB,击败了8.16% 的C++用户          
```

#### 37. 回文子串 647
```c++
class Solution {
public:
    int countSubstrings(string s) {
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(),false));
        int res = 0;
        for(int i=s.size()-1; i>=0; --i){
            for(int j=i; j<s.size(); ++j){
                if(s[i] == s[j]){
                    if(j-i <= 1){
                        ++res;
                        dp[i][j] = true;
                    }
                    else if(dp[i+1][j-1]){
                        ++res;
                        dp[i][j] = true;
                    }
                }
            }
        }
        return res;
    }
};
执行耗时:16 ms,击败了46.72% 的C++用户     
内存消耗:7.4 MB,击败了40.38% 的C++用户              
```

#### 37. 最长回文子序列 516
```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n, 0));
        for(int i=0; i<s.size(); ++i)
            dp[i][i] = 1;
        for(int i=n-1; i>=0; --i){
            for(int j=i+1; j<n; ++j){
                if(s[i] == s[j]){
                    dp[i][j] = dp[i+1][j-1] + 2;
                }else{
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
                }
            }
        }
        return dp[0][n-1];
    }
};
执行耗时:88 ms,击败了80.52% 的C++用户     
内存消耗:71.3 MB,击败了17.18% 的C++用户                        
```


