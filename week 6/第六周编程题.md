**二叉树前中后序遍历**     
1.144. 二叉树的前序遍历    
思路: 
```c++
class Solution {
public:
    vector<int> res;
    void preorder(TreeNode* root){
        if(root == nullptr)
            return ;
        res.push_back(root->val);
        preorder(root->left);
        preorder(root->right);
    }

    vector<int> preorderTraversal(TreeNode* root) {
        preorder(root);
        return res;
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户   
内存消耗:8.2 MB,击败了37.67% 的C++用户      
```

2.94. 二叉树的中序遍历  
思路:
```c++
class Solution {
public:
    vector<int> res;
    void inorder(TreeNode* root){
        if(root == nullptr)
            return ;
        inorder(root->left);
        res.push_back(root->val);
        inorder(root->right);
    }

    vector<int> inorderTraversal(TreeNode* root) {
        inorder(root);
        return res;
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户      
内存消耗:8 MB,击败了89.86% 的C++用户
```

3.145. 二叉树的后序遍历        
思路:
```c++
class Solution {
public:
    vector<int> res;
    void postorder(TreeNode* root){
        if(root == nullptr)
            return ;
        postorder(root->left);
        postorder(root->right);
        res.push_back(root->val);
    }

    vector<int> postorderTraversal(TreeNode* root) {
        postorder(root);
        return res;
    }
};
执行耗时:4 ms,击败了40.12% 的C++用户
内存消耗:8.3 MB,击败了31.19% 的C++用户
```

4.589. N 叉树的前序遍历    
思路:
```c++
class Solution {
public:
    vector<int> res;
    void pretravesal(Node* root){
        if(root == nullptr)
            return ;
        res.push_back(root->val);
        vector<Node*> child = root->children;
        for(auto it : child)
            pretravesal(it);
    }

    vector<int> preorder(Node* root) {
        pretravesal(root);
        return res;
    }
};
执行耗时:16 ms,击败了68.27% 的C++用户 
内存消耗:11.7 MB,击败了12.00% 的C++用户
```

5.590. N 叉树的后序遍历   
思路:
```c++
class Solution {
public:
    vector<int> res;
    void posttraversal(Node* root){
        if(root == nullptr)
            return ;
        vector<Node*> child = root->children;
        for(auto it : child){
            if(it == nullptr)
                continue;
            posttraversal(it);
            res.push_back(it->val);
        }
    }

    vector<int> postorder(Node* root) {
        if(root == nullptr)
            return {};
        posttraversal(root);
        res.push_back(root->val);
        return res;
    }
};
 执行耗时:16 ms,击败了69.77% 的C++用户 
 内存消耗:11.9 MB,击败了10.48% 的C++用户
```
___

**二叉树按层遍历**   
1.剑指 Offer 32 - I. 从上到下打印二叉树   
思路:
```c++
class Solution {
public:
    vector<int> levelOrder(TreeNode* root) {
        if(root == nullptr)
            return {};
        vector<int> ans;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            int size = q.size();
            for(int i=0; i<size; i++){
                TreeNode* tmp = q.front();
                q.pop();
                ans.push_back(tmp->val);

                if(tmp->left != nullptr)
                    q.push(tmp->left);
                if(tmp->right != nullptr)
                    q.push(tmp->right);
            }
        }
        return ans;
    }
};
执行耗时:4 ms,击败了67.53% 的C++用户    
内存消耗:12 MB,击败了5.97% 的C++用户
```

2.102. 二叉树的层序遍历   
思路:
```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root == nullptr)
            return res;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            vector<int> layer;
            int size = q.size();
            for(int i=0; i<size; i++){
                TreeNode* tmp = q.front();
                q.pop();
                layer.push_back(tmp->val);

                if(tmp->left != nullptr)
                    q.push(tmp->left);
                if(tmp->right != nullptr)
                    q.push(tmp->right);
            }
            res.push_back(layer);
        }
        return res;
    }
};
执行耗时:8 ms,击败了23.05% 的C++用户     
内存消耗:12.1 MB,击败了74.89% 的C++用户       
```

3.剑指 Offer 32 - III. 从上到下打印二叉树 III   
思路:
```c++


```

4.429. N 叉树的层序遍历  
思路:
```c++


```

5.513. 找树左下角的值   
思路:
```c++


```
___

**二叉树上的递归**   
1.104. 二叉树的最大深度  
思路:
```c++


```

2.559. N 叉树的最大深度  
思路:
```c++


```

3.剑指 Offer 55 - II. 平衡二叉树     
思路:
```c++


```

4.617. 合并二叉树   
思路:
```c++


```

5.226. 翻转二叉树   
思路:
```c++


```

6.101. 对称二叉树   
思路:
```c++


```

7.98. 验证二叉搜索树   
思路:
```c++


```
___

**二叉树上的递归**   
1.剑指 Offer 54. 二叉搜索树的第k大节点   
思路:
```c++


```

2.538. 把二叉搜索树转换为累加树   
思路:
```c++


```

3.面试题 04.06. 后继者   
思路:
```c++


```


