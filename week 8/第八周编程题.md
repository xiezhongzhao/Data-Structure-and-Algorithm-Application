**编程题**   
1.面试题 08.12. 八皇后     
思路: 初始行数为第一行，棋子可以选择摆放第一列到第n列，然后逐行摆放，在逐行摆放过程中要满足不在同行，同列，同对角线，
最后当遍历到棋盘最后一行时，记录符合要求的棋盘。
```c++
class Solution {
public:
    vector<vector<string>> res;
    bool isValid(int n, int row, int col, vector<string>& chessboard){
        // 0 degree
        for(int i=row-1; i>=0; i--){
            if(chessboard[i][col] == 'Q')
                return false;
        }
        // 45 degree
        for(int i=row-1,j=col-1; i>=0&&j>=0; i--,j--){
            if(chessboard[i][j] == 'Q')
                return false;
        }
        // 135 degree
        for(int i=row-1,j=col+1; i>=0&&j<n; i--,j++){
            if(chessboard[i][j] == 'Q')
                return false;
        }
        return true;
    }

    void backtracking(int n, int row, vector<string>& chessboard){
        if(row == n){
            res.push_back(chessboard);
            return ;
        }
        for(int col=0; col<n; col++){
            if(isValid(n, row, col, chessboard)){
                chessboard[row][col] = 'Q';
                backtracking(n, row+1, chessboard);
                chessboard[row][col] = '.';
            }
        }
    }

    vector<vector<string>> solveNQueens(int n) {
        vector<string> chessboard(n, string(n,'.'));
        backtracking(n, 0, chessboard);
        return res;
    }
};

执行耗时:4 ms,击败了89.89% 的C++用户      
内存消耗:7.3 MB,击败了57.01% 的C++用户        
```

2.37. **解数独**  
思路: 首先在填字表格中的位置，分别试着填入9个不同的数字, 然后判断横竖和区域中有没有相同的数字，如果没有相同数字，
那么直接填入该数字, 进入递归中填写下一个数字。
```c++
class Solution {
public:
    bool isValid(int row, int col, char val, vector<vector<char>>& board){
        for(int i=0; i<9; i++){
            if(board[row][i] == val)
                return false;
        }

        for(int j=0; j<9; j++){
            if(board[j][col] == val)
                return false;
        }

        int startRow = (row/3)*3;
        int startCol = (col/3)*3;
        for(int i=startRow; i<startRow+3; i++){
            for(int j=startCol; j<startCol+3; j++){
                if(board[i][j] == val)
                    return false;
            }
        }
        return true;
    }

    bool backtracking(vector<vector<char>>& board){
        int rows = board.size();
        int cols = board[0].size();
        for(int i=0; i<rows; i++){
            for(int j=0; j<cols; j++){
                if(board[i][j] != '.')
                    continue;
                for(char k='1'; k<='9'; k++){
                    if(isValid(i, j, k, board)){
                        board[i][j] = k;
                        if(backtracking(board))
                            return true;
                        board[i][j] = '.';
                    }
                }
                return false;
            }
        }
        return true;
    }

    void solveSudoku(vector<vector<char>>& board) {
        backtracking(board);
    }
};
执行耗时:48 ms,击败了8.17% 的C++用户    
内存消耗:6.2 MB,击败了80.93% 的C++用户      

```

3.17. **电话号码的字母组合**          
思路: 横向遍历是按键对应的字母，纵向递归的字符串的不同字符。
```c++
class Solution {
public:
    vector<string> res;
    void backtracking(const string& digits,
                      string ele,
                      map<char, string>& heap,
                      int index){
        if(ele.size() == digits.size()){
            res.push_back(ele);
            ele.clear();
            return ;
        }
        string tmp = heap[digits[index]];
        for(char w : tmp){
            ele += w;
            backtracking(digits, ele, heap, index+1);
            ele.pop_back();
        }
        return ;
    }

    vector<string> letterCombinations(string digits) {
        res.clear();
        if(digits.size() == 0)
            return res;

        map<char, string> heap{{'2',"abc"}, {'3',"def"}, {'4',"ghi"},
                               {'5',"jkl"}, {'6',"mno"}, {'7',"pqrs"},
                               {'8',"tuv"}, {'9',"wxyz"}
                              };
        backtracking(digits, "", heap, 0);
        return res;
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户 
内存消耗:6.3 MB,击败了76.07% 的C++用户

```

4.77. **组合**     
思路: 经典回溯模板
```c++
class Solution {
public:
    vector<vector<int>> res;
    void backtracking(int n, int k, int index, vector<int>& arr){
        if(arr.size() == k){
            res.push_back(arr);
            return ;
        }
        for(int i=index; i<=n; i++){
            arr.push_back(i);
            backtracking(n, k, i+1, arr);
            arr.pop_back();
        }
    }

    vector<vector<int>> combine(int n, int k) {
        vector<int> arr;
        backtracking(n, k, 1, arr);
        return res;
    }
};

执行耗时:20 ms,击败了60.20% 的C++用户   
内存消耗:9.8 MB,击败了50.63% 的C++用户     
```

5.78. 子集    
思路:
```c++


```

6.90. 子集 II  
思路:
```c++


```

7.46. 全排列     
思路:
```c++


```

8.47. 全排列 II  
思路:
```c++


```

9.39. 组合总和      
思路:
```c++
class Solution {
public:
//输入: candidates = [2,3,5], target = 8
//输出: [[2,2,2,2],[2,3,3],[3,5]]
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(vector<int>& arr, int index, int sum, int target){
        if(sum > target)
            return ;
        if(sum == target){
            res.push_back(path);
            return ;
        }
        for(int i=index; i<arr.size(); i++){
            sum += arr[i];
            path.push_back(arr[i]);
            backtracking(arr, i, sum, target);
            sum -= arr[i];
            path.pop_back();
        }
    }

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        res.clear();
        path.clear();
        backtracking(candidates, 0, 0, target);
        return res;
    }
};
 执行耗时:8 ms,击败了58.20% 的C++用户 
 内存消耗:11 MB,击败了41.44% 的C++用户
```

10.40. 组合总和 II    
思路:
```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(vector<int>& arr, int target, int index, int sum){
        if(sum > target)
            return ;
        if(sum == target){
            res.push_back(path);
            return ;
        }
        for(int i=index; i<arr.size(); i++){
            if(i>index && arr[i] == arr[i-1])
                continue;
            sum += arr[i];
            path.push_back(arr[i]);
            backtracking(arr, target, i+1, sum);
            sum -= arr[i];
            path.pop_back();
        }
    }

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        res.clear();
        path.clear();
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0);
        return res;
    }
};
执行耗时:4 ms,击败了89.98% 的C++用户 
内存消耗:10.3 MB,击败了83.83% 的C++用户
```

11.216. 组合总和 III  
思路:
```c++


```

12.131. 分割回文串  
思路:
```c++


```

13.93. 复原 IP 地址  
思路:
```c++


```

14.22. 括号生成  
思路:
```c++


```
