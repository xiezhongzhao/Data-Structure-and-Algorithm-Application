**动态规划编程题**   
**背包**   
1.416. 分割等和子集       
思路: 
```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(auto& it : nums) sum += it;
        if((sum&1) == 1) return false;
        int target = sum / 2;

        int len = nums.size();
        int dp[len][target+1];
        memset(dp, 0, sizeof(dp));

        dp[0][0] = true;
        if(nums[0] <= target)
            dp[0][nums[0]] = true;

        for(int i=1; i<len; i++){
            for(int j=0; j<=target; j++){
                dp[i][j] = dp[i-1][j]; // 不选当前数字nums[i]
                if(nums[i] <= j) //
                    dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]];
            }
            if(dp[i][target])
                return true;
        }
        return dp[len-1][target];
    }
};
执行耗时:80 ms,击败了92.54% 的C++用户 
内存消耗:17.4 MB,击败了20.69% 的C++用户
```
空间优化:      
```c++


```

2.494. 目标和  
思路:
```c++


```

3.322. 零钱兑换            
思路:
```c++


```

4.518. 零钱兑换 II      
思路:
```c++


```
___

**路径问题**   
1.64. 最小路径和       
思路:
```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int rows = grid.size();
        int cols = grid[0].size();
        vector<vector<int>> dp(rows, vector<int>(cols,0));

        dp[0][0] = grid[0][0];
        for(int i=1; i<rows; i++) dp[i][0] = dp[i-1][0] + grid[i][0];
        for(int j=1; j<cols; j++) dp[0][j] = dp[0][j-1] + grid[0][j];

        for(int i=1; i<rows; i++){
            for(int j=1; j<cols; j++){
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
            }
        }
        return dp[rows-1][cols-1];
    }
};
执行耗时:8 ms,击败了76.61% 的C++用户      
内存消耗:9.8 MB,击败了43.77% 的C++用户    
```

2.剑指 Offer 47. 礼物的最大价值  
思路:
```c++
class Solution {
public:
    int maxValue(vector<vector<int>>& grid) {
        int rows = grid.size();
        int cols = grid[0].size();
        vector<vector<int>> dp(rows, vector<int>(cols,0));
        dp[0][0] = grid[0][0];
        for(int i=1; i<rows; i++) dp[i][0] = dp[i-1][0] + grid[i][0];
        for(int j=1; j<cols; j++) dp[0][j] = dp[0][j-1] + grid[0][j];

        for(int i=1; i<rows; i++){
            for(int j=1; j<cols; j++){
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j];
            }
        }
        return dp[rows-1][cols-1];
    }
};
执行耗时:12 ms,击败了8.31% 的C++用户      
内存消耗:9 MB,击败了53.88% 的C++用户     
```

3.120. 三角形最小路径和            
思路:
```c++


```

4.62. 不同路径      
思路:
```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n,0));
        for(int i=0; i<m; i++)
            dp[i][0] = 1;
        for(int j=0; j<n; j++)
            dp[0][j] = 1;
        for(int i=1; i<m; i++){
            for(int j=1; j<n; j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户    
内存消耗:6.3 MB,击败了53.64% 的C++用户        
```

4.63. 不同路径 II      
思路:
```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int rows = obstacleGrid.size();
        int cols = obstacleGrid[0].size();
        if(obstacleGrid[rows-1][cols-1] == 1 || obstacleGrid[0][0] == 1)
            return 0;

        vector<vector<int>> dp(rows, vector<int>(cols,0));
        for(int i=0; i<rows&&obstacleGrid[i][0]==0; i++) dp[i][0] = 1;
        for(int j=0; j<cols&&obstacleGrid[0][j]==0; j++) dp[0][j] = 1;

        for(int i=1; i<rows; i++){
            for(int j=1; j<cols; j++){
                if(obstacleGrid[i][j] == 1)
                    continue;
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[rows-1][cols-1];
    }
};
 执行耗时:0 ms,击败了100.00% 的C++用户     
 内存消耗:7.5 MB,击败了66.73% 的C++用户      
```
___


**打家劫舍 & 买卖股票**   
1.198. 打家劫舍       
思路:
```c++


```

2.213. 打家劫舍 II  
思路:
```c++


```

3.337. 打家劫舍 III            
思路:
```c++


```

4.714. 买卖股票的最佳时机含手续      
思路:
```c++


```

4.309. 最佳买卖股票时机含冷冻期      
思路:
```c++


```