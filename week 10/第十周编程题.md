**动态规划编程题**   
**背包**   
1.416. 分割等和子集       
思路: 
```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(auto& it : nums) sum += it;
        if((sum&1) == 1) return false;
        int target = sum / 2;

        int len = nums.size();
        int dp[len][target+1];
        memset(dp, 0, sizeof(dp));

        dp[0][0] = true;
        if(nums[0] <= target)
            dp[0][nums[0]] = true;

        for(int i=1; i<len; i++){
            for(int j=0; j<=target; j++){
                dp[i][j] = dp[i-1][j]; // 不选当前数字nums[i]
                if(nums[i] <= j) //
                    dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]];
            }
            if(dp[i][target])
                return true;
        }
        return dp[len-1][target];
    }
};
执行耗时:80 ms,击败了92.54% 的C++用户 
内存消耗:17.4 MB,击败了20.69% 的C++用户
```
空间优化:      
```c++


```

2.494. 目标和  
思路: 回溯，有正负两种状态，可以类比为二叉树的左右节点，因此和二叉树的遍历情况相似
```c++
class Solution {
public:
    void dfs(vector<int>& nums, int target, int sum, int index, int& count){
        if(index == nums.size()){
            if(sum == target)
                count += 1;
            return ;
        }
        dfs(nums, target, sum+nums[index], index+1, count);
        dfs(nums, target, sum-nums[index], index+1, count);
    }

    int findTargetSumWays(vector<int>& nums, int target) {
        int n = nums.size();
        int count = 0;
        dfs(nums, target, 0, 0, count);
        return count;
    }
};
执行耗时:1140 ms,击败了22.72% 的C++用户      
内存消耗:8.6 MB,击败了97.64% 的C++用户
```
思路: 动态规划（背包）                
```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for(int i=0; i<nums.size(); i++) sum += nums[i];
        // x-(sum-x) = target
        if((sum+target)%2 == 1 || abs(target) > sum)
            return 0;
        int m = nums.size();
        int n = (sum+target)/2 + 1;
        cout << "m: " << m << ", " << "n: " << n << endl;

        int dp[m][n];
        memset(dp, 0, sizeof(dp));
        // initial
        dp[0][0] = 1;
        for(int j=0; j<n; j++){
            if(nums[0] == j)
                dp[0][j] += 1;
        }
        for(int i=1; i<m; i++){
            for(int j=0; j<n; j++){
                if(j<nums[i])
                    dp[i][j] = dp[i-1][j];
                else
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]];
            }
        }
        return dp[m-1][n-1];
    }
};
执行耗时:8 ms,击败了78.34% 的C++用户      
内存消耗:8.6 MB,击败了95.05% 的C++用户        

```

3.322. 零钱兑换            
思路: dfs+记忆剪枝
```c++
class Solution {
public:
//输入：coins = [1, 2, 5], amount = 11
//输出：3
//解释：11 = 5 + 5 + 1
    int dfs(vector<int>& coins, int target, int index, unordered_map<int,int>& hash){
        if(target < 0)
            return -1;
        if(target == 0){
            return 0;
        }
        if(hash.find(target) != hash.end())
            return hash[target];
        int ans = INT_MAX;
        for(int i=0; i<coins.size(); i++){
            int t = dfs(coins, target-coins[i], index+1, hash);
            if(t>=0 && t<ans)
                ans = t+1;
        }
        hash[target] = (ans == INT_MAX ? -1 : ans);
        return hash[target];
    }

    int coinChange(vector<int>& coins, int amount) {
        unordered_map<int,int> hash;
        return dfs(coins, amount, 0, hash);
    }
};
执行耗时:412 ms,击败了5.02% 的C++用户      
内存消耗:63.4 MB,击败了5.03% 的C++用户       
```

思路: bfs
```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        sort(coins.begin(), coins.end(), greater<int>());

        queue<int> q;
        q.push(amount);
        unordered_set<int> vis;
        vis.insert(amount);

        int ans = 0;
        while(!q.empty()){
            int size = q.size();
            while(size--){
                int top = q.front();
                q.pop();
                if(top == 0) return ans;
                for(int i=0; i<coins.size(); i++){
                    int num = top - coins[i];
                    if(!vis.count(num) && num>=0){
                        vis.insert(num);
                        q.push(num);
                    }
                }
            }
            ++ans;
        }
        return -1;
    }
};
执行耗时:296 ms,击败了5.02% 的C++用户     
内存消耗:61.9 MB,击败了5.03% 的C++用户    
```

思路: 动态规划(滚动数组)
```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount+1, amount+1);
        dp[0] = 0;
        for(int i=0; i<dp.size(); i++){
            for(int coin : coins){
                if(i-coin < 0)
                    continue;
                dp[i] = min(dp[i], 1+dp[i-coin]);
            }
        }
        return (dp[amount] == amount+1) ? -1 : dp[amount];
    }
};

执行耗时:80 ms,击败了51.59% 的C++用户     
内存消耗:14.1 MB,击败了30.77% 的C++用户    
```

王争思路：动态规划（二维数组）      
```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size();
        vector<vector<int>> dp(n, vector<int>(amount+1, INT_MAX));
        for(int i=0; i<=amount/coins[0]; i++){
            dp[0][i*coins[0]] = i;
        }
        for(int i=1; i<n; i++){
            for(int j=0; j<=amount; j++){
                int k = j/coins[i];
                for(int c=0; c<=k; c++){
                    if(dp[i-1][j-c*coins[i]] != INT_MAX &&
                    dp[i-1][j-c*coins[i]]+c < dp[i][j])
                        dp[i][j] = dp[i-1][j-c*coins[i]] + c;
                }
            }
        }
        return dp[n-1][amount] == INT_MAX ? -1 : dp[n-1][amount];
    }
};
该写法超时
```

4.518. 零钱兑换 II      
思路:
```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount+1, 0);
        dp[0] = 1;
        for(int i=0; i<coins.size(); i++){
            for(int j=coins[i]; j<=amount; j++){
                dp[j] += dp[j-coins[i]];
            }
        }
        return dp[amount];
    }
};
执行耗时:8 ms,击败了90.05% 的C++用户       
内存消耗:7.1 MB,击败了21.34% 的C++用户      
```
王争思路：  
```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int n = coins.size();
        vector<vector<int>> dp(n, vector<int>(amount+1, 0));
        for(int i=0; i<=amount/coins[0]; i++){
            dp[0][i*coins[0]] = 1;
        }
        for(int i=1; i<n; i++){
            for(int j=0; j<=amount; j++){
                int k = j/coins[i];
                for(int c=0; c<=k; c++){
                    dp[i][j] += dp[i-1][j-c*coins[i]];
                }
            }
        }
        return dp[n-1][amount];
    }
};
执行耗时:224 ms,击败了5.03% 的C++用户      
内存消耗:17.8 MB,击败了16.75% 的C++用户       
```
___

**路径问题**   
1.64. 最小路径和       
思路:
```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int rows = grid.size();
        int cols = grid[0].size();
        vector<vector<int>> dp(rows, vector<int>(cols,0));

        dp[0][0] = grid[0][0];
        for(int i=1; i<rows; i++) dp[i][0] = dp[i-1][0] + grid[i][0];
        for(int j=1; j<cols; j++) dp[0][j] = dp[0][j-1] + grid[0][j];

        for(int i=1; i<rows; i++){
            for(int j=1; j<cols; j++){
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
            }
        }
        return dp[rows-1][cols-1];
    }
};
执行耗时:8 ms,击败了76.61% 的C++用户      
内存消耗:9.8 MB,击败了43.77% 的C++用户    
```

2.剑指 Offer 47. 礼物的最大价值  
思路:
```c++
class Solution {
public:
    int maxValue(vector<vector<int>>& grid) {
        int rows = grid.size();
        int cols = grid[0].size();
        vector<vector<int>> dp(rows, vector<int>(cols,0));
        dp[0][0] = grid[0][0];
        for(int i=1; i<rows; i++) dp[i][0] = dp[i-1][0] + grid[i][0];
        for(int j=1; j<cols; j++) dp[0][j] = dp[0][j-1] + grid[0][j];

        for(int i=1; i<rows; i++){
            for(int j=1; j<cols; j++){
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j];
            }
        }
        return dp[rows-1][cols-1];
    }
};
执行耗时:12 ms,击败了8.31% 的C++用户      
内存消耗:9 MB,击败了53.88% 的C++用户     
```

3.120. 三角形最小路径和            
思路:
```c++


```

4.62. 不同路径      
思路:
```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n,0));
        for(int i=0; i<m; i++)
            dp[i][0] = 1;
        for(int j=0; j<n; j++)
            dp[0][j] = 1;
        for(int i=1; i<m; i++){
            for(int j=1; j<n; j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户    
内存消耗:6.3 MB,击败了53.64% 的C++用户        
```

4.63. 不同路径 II      
思路:
```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int rows = obstacleGrid.size();
        int cols = obstacleGrid[0].size();
        if(obstacleGrid[rows-1][cols-1] == 1 || obstacleGrid[0][0] == 1)
            return 0;

        vector<vector<int>> dp(rows, vector<int>(cols,0));
        for(int i=0; i<rows&&obstacleGrid[i][0]==0; i++) dp[i][0] = 1;
        for(int j=0; j<cols&&obstacleGrid[0][j]==0; j++) dp[0][j] = 1;

        for(int i=1; i<rows; i++){
            for(int j=1; j<cols; j++){
                if(obstacleGrid[i][j] == 1)
                    continue;
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[rows-1][cols-1];
    }
};
 执行耗时:0 ms,击败了100.00% 的C++用户     
 内存消耗:7.5 MB,击败了66.73% 的C++用户      
```
___


**打家劫舍 & 买卖股票**   
1.198. 打家劫舍       
思路:
```c++


```

2.213. 打家劫舍 II  
思路:
```c++


```

3.337. 打家劫舍 III            
思路:
```c++


```

4.714. 买卖股票的最佳时机含手续      
思路:
```c++


```

4.309. 最佳买卖股票时机含冷冻期      
思路:
```c++


```