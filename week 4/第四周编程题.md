**递归编程题**   
1.剑指offer 10-I.斐波拉契数列       
思路: 采用递归的方法，在递归过程中记录之间算过的值，用数组存储。 
```c++
class Solution {
public:
//F(0) = 0,   F(1) = 1
//F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
    int cache[101];
    int fib(int n) {
        if(n == 0)
            return 0;
        if(n == 1)
            return 1;
        int a=0, b=0;
        a = fib(n-1);

        if(cache[n-2])
            b = cache[n-2];
        else
            b = fib(n-2);

        int res = (a+b)%1000000007;
        cache[n] = res;
        return res;
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户
内存消耗:5.8 MB,击败了87.18% 的C++用户
```

2.剑指offer 10-II.青蛙跳台阶问题    
思路: 与斐波拉契问题一样，只是初始值不相同
```c++
class Solution {
public:
    int cache[101];
    int numWays(int n) {
        if(n == 0)
            return 1;
        if(n == 1)
            return 1;
        int a=0, b=0;
        a = numWays(n-1);

        if(cache[n-2])
            b = cache[n-2];
        else
            b = numWays(n-2);
        int result = (a + b)%1000000007;
        cache[n] = result;
        return result;
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户 
内存消耗:5.9 MB,击败了48.07% 的C++用户

```

3.面试题08.01. 三步问题   
思路:
```c++
class Solution {
public:
    int cache[1000001];
    int waysToStep(int n) {
        if(n == 0)
            return 1;
        if(n == 1)
            return 1;
        if(n == 2)
            return 2;
        long a=0, b=0, c=0;
        a = waysToStep(n-1);

        if(cache[n-2])
            b = cache[n-2];
        else
            b = waysToStep(n-2);

        if(cache[n-3])
            c = cache[n-3];
        else
            c = waysToStep(n-3);

        int result = (a+b+c)%1000000007;
        cache[n] = result;

        return result;
    }
};
 执行耗时:32 ms,击败了17.57% 的C++用户 
 内存消耗:52.6 MB,击败了5.06% 的C++用户
```

4.剑指offer 06.从尾到头打印链表  
思路: 运用递归的特点
```c++
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        if(head == nullptr)
            return {};
        vector<int> res = reversePrint(head->next);
        res.push_back(head->val);
        return res;
    }
};
执行耗时:4 ms,击败了73.90% 的C++用户
内存消耗:10.9 MB,击败了8.29% 的C++用户
```

5.剑指offer 24.反转链表  
思路:  
```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head == nullptr || head->next == nullptr)
            return head;

        ListNode* pNode = reverseList(head->next);
        cout << "val: " << head->val << endl;
        head->next->next = head;
        head->next = nullptr;
        return pNode;
    }
};
执行耗时:8 ms,击败了49.40% 的C++用户   
内存消耗:8.4 MB,击败了5.30% 的C++用户    
```

6.剑指offer 25.合并两个排序链表  
思路: 
```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(l1 == nullptr)
            return l2;
        if(l2 == nullptr)
            return l1;

        ListNode* pMerge = nullptr;
        if(l1->val <= l2->val){
            pMerge = l1;
            pMerge->next = mergeTwoLists(l1->next, l2);
        }
        else{
            pMerge = l2;
            pMerge->next = mergeTwoLists(l1, l2->next);
        }
        return pMerge;
    }
};
执行耗时:16 ms,击败了92.96% 的C++用户   
内存消耗:18.7 MB,击败了36.79% 的C++用户     
```

7.剑指offer 16.**数值的整数次方**   
思路: 快速幂解析，
```c++
class Solution {
public:
    double myPow(double x, int n) {
        double res=1.0;
        long N=n;
        if(n<0){
            N = -N;
            x = 1/x;
        }
        while(N>0){
            cout << "N: " << N << endl;
            if(N&1)
                res *= x;
            x*=x;
            N>>=1;
        }
        return res;
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户
内存消耗:5.8 MB,击败了85.65% 的C++用户
```

8.面试题08.05. 递归乘法   
思路: 将乘法转化为加法即可。   
```c++
class Solution {
public:
    int multiply(int A, int B) {
        if(B == 0)
            return 0;
        return A+multiply(A, B-1);
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户
内存消耗:5.7 MB,击败了93.73% 的C++用户
```
___


**排序编程题**        
1.面试题 10.01. 合并排序的数组        
思路:
```c++


```

2.242. 有效的字母异位词   
思路:
```c++


```

3.1502. 判断能否形成等差数列  
思路:
```c++


```

4.252. 会议室  
思路:
```c++


```

5.56. 合并区间  
思路:
```c++


```

6.剑指 Offer 21. 调整数组顺序使奇数位于偶数前面  
思路:
```c++


```

7.75. 颜色分类  
思路:
```c++


```

8.147. 对链表进行插入排序  
思路:
```c++


```

9.148. 排序链表  
思路:
```c++


```

10.215. 数组中的第K个最大元素  
思路:
```c++


```

11.面试题 17.14. 最小K个数  
思路:
```c++


```

12.剑指 Offer 51. 数组中的逆序对  
思路:
```c++


```



