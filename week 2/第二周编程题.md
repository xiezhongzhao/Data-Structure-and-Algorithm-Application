**编程题**   
1.203.移除链表元素      
思路: 首先设置一个dummy节点指向头节点，然后在遍历链表节点pNode时，记录前指针pPre和后指针pNext，
如果节点的值和目标值相等时，调整前指针指向后指针，不相等时当前节点变为前指针。
```c++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if(head == nullptr)
            return nullptr;
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* pNode = head;
        ListNode* pPre = dummy;

        while(pNode){
            ListNode* pNext = pNode->next;
            if(pNode->val == val){
                pPre->next = pNext;
            }else{
                pPre = pNode;
            }
            pNode = pNode->next;
        }

        return dummy->next;
    }
};
执行耗时:16 ms,击败了94.22% 的C++用户     
内存消耗:14.6 MB,击败了82.24% 的C++用户     
```

2.876.链表的中间结点    
思路: 首先遍历一遍链表，找出中间节点所在位置`mid`，然后再次遍历到`mid`位置，返回该节点。 
```c++
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        if(head == nullptr)
            return nullptr;
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        int count = 0;
        ListNode* pNode = head;
        while(pNode){
            ++count;
            pNode = pNode->next;
        }
        ListNode* pMid = head;
        int mid = count/2 + 1;
        while(--mid){
            pMid = pMid->next;
        }
        return pMid;
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户      
内存消耗:6.8 MB,击败了86.63% 的C++用户
```

3.**删除排序链表中的重复元素**          
思路: 首先定义一个虚拟节点指向头指针，然后开始遍历节点，当前节点`pNode`等于下一个节点`pNode->next`时，
那么当前节点`pNode`指向`pNode->next->next`。
```c++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(head == nullptr || head->next == nullptr)
            return head;
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;

        ListNode* pNode = head;
        while(pNode->next != nullptr){
            if(pNode->val == pNode->next->val)
                pNode->next = pNode->next->next;
            else{
                pNode = pNode->next;
            }
        }
        return dummy->next;
    }
};
 执行耗时:8 ms,击败了82.93% 的C++用户     
 内存消耗:11.3 MB,击败了25.08% 的C++用户    
```

4.剑指offer 25.合并两个排序的链表     
思路: 首先定义合并后的头指针`pMerge`，然后开始遍历`l1`, `l2`, 比较`l1->val`和`l2->val`的值，
`pMerge`合并较小的值，最后返回合并完成后的链表头节点。  
```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(l1 == nullptr)
            return l2;
        if(l2 == nullptr)
            return l1;
        ListNode* dummy = new ListNode(-1);
        ListNode* pMerge = new ListNode(0);
        dummy->next = pMerge;

        while(l1 && l2){
            if(l1->val > l2->val){
                pMerge->next = new ListNode(l2->val);
                l2 = l2->next;
            }else if(l1->val < l2->val){
                pMerge->next = new ListNode(l1->val);
                l1 = l1->next;
            }else{
                pMerge->next = new ListNode(l1->val);
                pMerge = pMerge->next;
                pMerge->next = new ListNode(l2->val);

                l1 = l1->next;
                l2 = l2->next;
            }
            pMerge = pMerge->next;
        }
        while(l1){
            pMerge->next = new ListNode(l1->val);
            pMerge = pMerge->next;
            l1 = l1->next;
        }
        while(l2){
            pMerge->next = new ListNode(l2->val);
            pMerge = pMerge->next;
            l2 = l2->next;
        }
        return dummy->next->next;
    }
};
执行耗时:20 ms,击败了75.28% 的C++用户     
内存消耗:19.6 MB,击败了5.04% 的C++用户      
```
```c++
//合并N个排序链表  
思路: 首先定义一个优先级队列（小根堆），堆顶为最小数值，然后将容器中所有链表的节点对应的值压入堆中，
最后依次弹出堆顶元素，构成合并链表。
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        int size = lists.size();
        if(size == 0)
            return nullptr;
        ListNode* dummy = new ListNode(0);
        ListNode* pMerge = new ListNode(-1);
        dummy->next = pMerge;

        std::priority_queue<int, deque<int>, greater<int>> q;
        for(int i=0; i<size; i++){
            ListNode* pNode = lists[i];
            while(pNode){
               q.push(pNode->val);
               pNode = pNode->next;
            }
        }
        while(!q.empty()){
            pMerge->next = new ListNode(q.top());
            q.pop();
            pMerge = pMerge->next;
        }
        pMerge->next = nullptr;
        return dummy->next->next;
    }
};
执行耗时:36 ms,击败了27.49% 的C++用户     
内存消耗:13.6 MB,击败了26.66% 的C++用户    
```

5.两数相加      
思路:
```c++


```

6.206.反转链表       
思路:
```c++


```

7.234.回文链表      
思路:
```c++


```

8.328.奇偶链表      
思路:
```c++


```

9.25.K个一组翻转链表      
思路:
```c++


```

10.剑指offer22.链表中倒数第k个节点   
思路:
```c++


```

11.19.删除链表的倒数第N个节点   
思路:
```c++


```

12.160.相交链表   
思路:
```c++


```

13.141.环形链表   
思路:
```c++


```

