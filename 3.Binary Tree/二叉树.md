[TOC]
#### 二叉树的遍历方式
144.二叉树的前序遍历
```c++
class Solution {
public:
    vector<int> res;
    void dfs(TreeNode* root){
        if(root == nullptr)
            return ;
        res.emplace_back(root->val);
        dfs(root->left);
        dfs(root->right);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        dfs(root);
        return res;
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户      
内存消耗:8.3 MB,击败了19.38% 的C++用户     
```

145.二叉树的后序遍历
```c++
class Solution {
public:
    vector<int> res;
    void dfs(TreeNode* root){
        if(root == nullptr)
            return ;
        dfs(root->left);
        dfs(root->right);
        res.emplace_back(root->val);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        dfs(root);
        return res;
    }
};
执行耗时:4 ms,击败了41.35% 的C++用户       
内存消耗:8.3 MB,击败了20.87% 的C++用户       
```

94.二叉树的中序遍历
```c++
class Solution {
public:
    vector<int> res;
    void dfs(TreeNode* root){
        if(root == nullptr)
            return ;
        dfs(root->left);
        res.emplace_back(root->val);
        dfs(root->right);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        dfs(root);
        return res;
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户        
内存消耗:8 MB,击败了89.01% 的C++用户        
```

102.二叉树的层序遍历
```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        res.clear();
        if(root == nullptr)
            return res;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            vector<int> layer;
            layer.clear();
            int size = q.size();
            for(int i=0; i<size; ++i){
                TreeNode* node = q.front();
                layer.emplace_back(node->val);
                q.pop();

                if(node->left)
                    q.push(node->left);
                if(node->right)
                    q.push(node->right);
            }
            res.emplace_back(layer);
        }
        return res;
    }
};
执行耗时:4 ms,击败了68.64% 的C++用户        
内存消耗:12.2 MB,击败了49.81% 的C++用户             
```
___

#### 二叉树的属性
101.对称二叉树
递归版本
```c++
class Solution {
public:
    bool dfs(TreeNode* p, TreeNode* q){
        if(!p && q)
            return false;
        if(p && !q)
            return false;
        if(!p && !q)
            return true;
        if(p->val != q->val)
            return false;
        return dfs(p->left, q->right) && dfs(p->right, q->left);
    }

    bool isSymmetric(TreeNode* root) {
        if(root == nullptr)
            return true;
        return dfs(root, root);
    }
};
执行耗时:4 ms,击败了76.58% 的C++用户              
内存消耗:15.9 MB,击败了89.97% 的C++用户                
```
迭代版本
```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root == nullptr)
            return true;
        queue<TreeNode*> q;
        q.push(root->left);
        q.push(root->right);
        while(!q.empty()){
            TreeNode* leftNode = q.front();
            q.pop();
            TreeNode* rightNode = q.front();
            q.pop();

            if(!leftNode && !rightNode)
                continue;
            if((!leftNode && rightNode)
                || (leftNode && !rightNode)
                || (leftNode->val != rightNode->val))
                return false;
            q.push(leftNode->left);
            q.push(rightNode->right);
            q.push(leftNode->right);
            q.push(rightNode->left);
        }
        return true;
    }
};
执行耗时:8 ms,击败了35.18% 的C++用户        
内存消耗:16.2 MB,击败了16.34% 的C++用户      
```

104.二叉树的最大深度
```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr)
            return 0;
        int left = 1 + maxDepth(root->left);
        int right = 1 + maxDepth(root->right);
        return max(left, right);
    }
};
执行耗时:20 ms,击败了6.64% 的C++用户        
内存消耗:18.3 MB,击败了75.09% 的C++用户         
```

111.二叉树的最小深度
```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root == nullptr)
            return 0;
        if(root->left == nullptr && root->right != nullptr){
            return 1 + minDepth(root->right);
        }
        if(root->left != nullptr && root->right == nullptr){
            return 1 + minDepth(root->left);
        }
        return 1 + min(minDepth(root->left), minDepth(root->right));
    }
};
执行耗时:220 ms,击败了76.57% 的C++用户       
内存消耗:141.3 MB,击败了40.85% 的C++用户            
```

222.完全二叉树的节点个数
层序遍历版本：   
```c++
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == nullptr)
            return 0;
        int count = 0;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            int n = q.size();
            for(int i=0; i<n; ++i){
                TreeNode* node = q.front();
                q.pop();
                ++count;
                if(node->left)
                    q.push(node->left);
                if(node->right)
                    q.push(node->right);
            }
        }
        return count;
    }
};
执行耗时:28 ms,击败了77.30% 的C++用户      
内存消耗:30.7 MB,击败了18.20% 的C++用户              
```
递归版本
```c++
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == nullptr)
            return 0;
        return 1 + countNodes(root->left) + countNodes(root->right);
    }
};
执行耗时:28 ms,击败了77.30% 的C++用户      
内存消耗:30.1 MB,击败了60.77% 的C++用户        
```
利用完全二叉树特性版本：
```c++
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == nullptr)
            return 0;
        int leftTreeHeight = 0, rightTreeHeight = 0;
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        while(left){
            ++leftTreeHeight;
            left = left->left;
        }
        while(right){
            ++rightTreeHeight;
            right = right->right;
        }
        if(leftTreeHeight == rightTreeHeight){
            return (2<<leftTreeHeight) - 1;
        }
        return 1 + countNodes(root->left) + countNodes(root->right);
    }
};
执行耗时:24 ms,击败了92.21% 的C++用户       
内存消耗:30.1 MB,击败了40.86% 的C++用户        
```

110.平衡二叉树
```c++
class Solution {
public:
    int treeHeight(TreeNode* root){
        if(root == nullptr)
            return 0;
        return 1 + max(treeHeight(root->left), treeHeight(root->right));
    }
    bool isBalanced(TreeNode* root) {
        if(root == nullptr)
            return true;
        int left = treeHeight(root->left);
        int right = treeHeight(root->right);
        if(abs(right-left) > 1)
            return false;
        return isBalanced(root->left) && isBalanced(root->right);
    }
};
执行耗时:8 ms,击败了88.41% 的C++用户          
内存消耗:20.6 MB,击败了11.31% 的C++用户        
```

257.二叉树的所有路径
```c++
class Solution {
public:
    vector<string> res;
    string path;
    void dfs(TreeNode* root, string path){
        path += to_string(root->val);
        if(root->left == nullptr && root->right == nullptr){
            res.emplace_back(path);
            return ;
        }
        if(root->left)
            dfs(root->left, path+"->");
        if(root->right)
            dfs(root->right, path+"->");
    }

    vector<string> binaryTreePaths(TreeNode* root) {
        res.clear();
        path.clear();
        if(root == nullptr)
            return res;
        dfs(root, path);
        return res;
    }
};
执行耗时:12 ms,击败了1.83% 的C++用户          
内存消耗:12.8 MB,击败了25.87% 的C++用户                
```

404.左叶子和
```c++
class Solution {
public:
    void dfs(TreeNode* root, int& sum){
        if(root == nullptr)
            return ;
        if(root->left){
            if(root->left->left == nullptr && root->left->right == nullptr){
                sum += root->left->val;
            }
        }
        dfs(root->left, sum);
        dfs(root->right, sum);
    }
    int sumOfLeftLeaves(TreeNode* root) {
        if(root == nullptr)
            return 0;
        int sum = 0;
        dfs(root, sum);
        return sum;
    }
};
执行耗时:0 ms,击败了100.00% 的C++用户      
内存消耗:13 MB,击败了72.48% 的C++用户           
```

513.找树左下脚的值
```c++
class Solution {
public:
    int maxDepth = INT_MIN;
    int res;
    void dfs(TreeNode* root, int height){
        if(root == nullptr)
            return ;
        if(root->left == nullptr && root->right == nullptr){
            if(height > maxDepth){
                res = root->val;
                maxDepth = height;
            }
        }
        dfs(root->left, height+1);
        dfs(root->right, height+1);
    }
    int findBottomLeftValue(TreeNode* root) {
        dfs(root, 0);
        return res;
    }
};
执行耗时:12 ms,击败了60.90% 的C++用户   
内存消耗:21.2 MB,击败了47.47% 的C++用户      
```

112.路径总和
```c++
class Solution {
public:
    bool flag = false;
    void dfs(TreeNode* root, int targetSum){
        if(root == nullptr)
            return ;
        if(!root->left && !root->right && targetSum-root->val == 0){
            flag = true;
        }
        dfs(root->left, targetSum-root->val);
        dfs(root->right, targetSum-root->val);
    }

    bool hasPathSum(TreeNode* root, int targetSum) {
        dfs(root, targetSum);
        return flag;
    }
};
执行耗时:16 ms,击败了16.93% 的C++用户       
内存消耗:20.7 MB,击败了53.24% 的C++用户           
```
___

#### 二叉树的修改与构造
226.翻转二叉树
```c++

```

105.从中序与后序遍历序列构造二叉树
```c++

```

654.最大二叉树
```c++

```

617.合并二叉树
```c++

```
___

#### 求二叉搜索树的属性
700.二叉搜索树中的搜索
```c++

```
98.验证二叉搜索树
```c++

```
530.二叉搜索树的最小绝对差
```c++

```
501.二叉搜索树中众树
```c++

```
538.把二叉搜索树转换为累加树
```c++

```
___

#### 二叉树公共祖先问题
236.二叉树的最近公共祖先
```c++

```
235.二叉搜索树的最近公共祖先
```c++

```
___

#### 二叉搜索树的修改与构造
701.二叉搜索树中插入操作
```c++

```

450.删除二叉搜索树中节点
```c++

```

669.修剪二叉搜索树
```c++

```

108.将有序数组转换为二叉搜索树
```c++

```
___

